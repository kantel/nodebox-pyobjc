
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sympy.matrices.matrices &#8212; SymPy 1.1.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="http://docs.sympy.org/latest/_modules/sympy/matrices/matrices.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.matrices.matrices</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="k">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">sympy.core.basic</span> <span class="k">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="k">import</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">sympy.core.power</span> <span class="k">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ilcm</span><span class="p">,</span> <span class="n">Float</span>
<span class="kn">from</span> <span class="nn">sympy.core.singleton</span> <span class="k">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="k">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> \
    <span class="n">NotIterable</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">PurePoly</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">simplify</span> <span class="k">as</span> <span class="n">_simplify</span><span class="p">,</span> <span class="n">signsimp</span><span class="p">,</span> <span class="n">nsimplify</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">numbered_symbols</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.miscellaneous</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="k">import</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="k">import</span> <span class="n">sstr</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">sympy.assumptions.refine</span> <span class="k">import</span> <span class="n">refine</span>
<span class="kn">from</span> <span class="nn">sympy.core.decorators</span> <span class="k">import</span> <span class="n">call_highest_priority</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">FunctionType</span>

<span class="kn">from</span> <span class="nn">.common</span> <span class="k">import</span> <span class="p">(</span><span class="n">a2idx</span><span class="p">,</span> <span class="n">classof</span><span class="p">,</span> <span class="n">MatrixError</span><span class="p">,</span> <span class="n">ShapeError</span><span class="p">,</span>
        <span class="n">NonSquareMatrixError</span><span class="p">,</span> <span class="n">MatrixCommon</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_iszero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if x is zero.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">is_zero</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">DeferredVector</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">NotIterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A vector whose components are deferred (e.g. for use with lambdify)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import DeferredVector, lambdify</span>
<span class="sd">    &gt;&gt;&gt; X = DeferredVector( &#39;X&#39; )</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    X</span>
<span class="sd">    &gt;&gt;&gt; expr = (X[0] + 2, X[2] + 3)</span>
<span class="sd">    &gt;&gt;&gt; func = lambdify( X, expr)</span>
<span class="sd">    &gt;&gt;&gt; func( [1, 2, 3] )</span>
<span class="sd">    (3, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;DeferredVector index out of range&#39;</span><span class="p">)</span>
        <span class="n">component_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">component_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;DeferredVector(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">MatrixDeterminant</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides basic matrix determinant operations.</span>
<span class="sd">    Should not be instantiated directly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_eval_berkowitz_toeplitz_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return (A,T) where T the Toeplitz matrix used in the Berkowitz algorithm</span>
<span class="sd">        corresponding to `self` and A is the first principal submatrix.&quot;&quot;&quot;</span>

        <span class="c1"># the 0 x 0 case is trivial</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">])</span>

        <span class="c1">#</span>
        <span class="c1"># Partition self = [ a_11  R ]</span>
        <span class="c1">#                  [ C     A ]</span>
        <span class="c1">#</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>   <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1">#</span>
        <span class="c1"># The Toeplitz matrix looks like</span>
        <span class="c1">#</span>
        <span class="c1">#  [ 1                                     ]</span>
        <span class="c1">#  [ -a         1                          ]</span>
        <span class="c1">#  [ -RC       -a        1                 ]</span>
        <span class="c1">#  [ -RAC     -RC       -a       1         ]</span>
        <span class="c1">#  [ -RA**2C -RAC      -RC      -a       1 ]</span>
        <span class="c1">#  etc.</span>

        <span class="c1"># Compute the diagonal entries.</span>
        <span class="c1"># Because multiplying matrix times vector is so much</span>
        <span class="c1"># more efficient than matrix times matrix, recursively</span>
        <span class="c1"># compute -R * A**n * C.</span>
        <span class="n">diags</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">diags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">diags</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">diags</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">R</span><span class="o">*</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">diags</span><span class="p">]</span>
        <span class="n">diags</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">diags</span>

        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">return</span> <span class="n">diags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">toeplitz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">toeplitz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_berkowitz_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run the Berkowitz algorithm and return a vector whose entries</span>
<span class="sd">            are the coefficients of the characteristic polynomial of `self`.</span>

<span class="sd">            Given N x N matrix, efficiently compute</span>
<span class="sd">            coefficients of characteristic polynomials of &#39;self&#39;</span>
<span class="sd">            without division in the ground domain.</span>

<span class="sd">            This method is particularly useful for computing determinant,</span>
<span class="sd">            principal minors and characteristic polynomial when &#39;self&#39;</span>
<span class="sd">            has complicated coefficients e.g. polynomials. Semi-direct</span>
<span class="sd">            usage of this algorithm is also important in computing</span>
<span class="sd">            efficiently sub-resultant PRS.</span>

<span class="sd">            Assuming that M is a square matrix of dimension N x N and</span>
<span class="sd">            I is N x N identity matrix, then the Berkowitz vector is</span>
<span class="sd">            an N x 1 vector whose entries are coefficients of the</span>
<span class="sd">            polynomial</span>

<span class="sd">                           charpoly(M) = det(t*I - M)</span>

<span class="sd">            As a consequence, all polynomials generated by Berkowitz</span>
<span class="sd">            algorithm are monic.</span>

<span class="sd">           For more information on the implemented algorithm refer to:</span>

<span class="sd">           [1] S.J. Berkowitz, On computing the determinant in small</span>
<span class="sd">               parallel time using a small number of processors, ACM,</span>
<span class="sd">               Information Processing Letters 18, 1984, pp. 147-150</span>

<span class="sd">           [2] M. Keber, Division-Free computation of sub-resultants</span>
<span class="sd">               using Bezout matrices, Tech. Report MPI-I-2006-1-006,</span>
<span class="sd">               Saarbrucken, 2006</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># handle the trivial cases</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">submat</span><span class="p">,</span> <span class="n">toeplitz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_berkowitz_toeplitz_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">toeplitz</span> <span class="o">*</span> <span class="n">submat</span><span class="o">.</span><span class="n">_eval_berkowitz_vector</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_eval_det_bareiss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using Bareiss&#39; fraction-free</span>
<span class="sd">        algorithm which is an extension of the well known Gaussian</span>
<span class="sd">        elimination method. This approach is best suited for dense</span>
<span class="sd">        symbolic matrices and will result in a determinant with</span>
<span class="sd">        minimal number of fractions. It means that less term</span>
<span class="sd">        rewriting is needed on resulting formulae.</span>

<span class="sd">        TODO: Implement algorithm for sparse matrices (SFF),</span>
<span class="sd">        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># XXX included as a workaround for issue #12362.  Should use `_find_reasonable_pivot` instead</span>
        <span class="k">def</span> <span class="nf">_find_pivot</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


        <span class="c1"># Recursively implimented Bareiss&#39; algorithm as per Deanna Richelle Leggett&#39;s</span>
        <span class="c1"># thesis http://www.math.usm.edu/perry/Research/Thesis_DRL.pdf</span>
        <span class="k">def</span> <span class="nf">bareiss</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cumm</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">elif</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># find a pivot and extract the remaining matrix</span>
            <span class="c1"># XXX should use `_find_reasonable_pivot`.  Blocked by issue #12362</span>
            <span class="n">pivot_pos</span><span class="p">,</span> <span class="n">pivot_val</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_find_pivot</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pivot_pos</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="c1"># if we have a valid pivot, we&#39;ll do a &quot;row swap&quot;, so keep the</span>
            <span class="c1"># sign of the det</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">pivot_pos</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># we want every row but the pivot row and every column</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">pivot_pos</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
            <span class="n">tmp_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">pivot_val</span><span class="o">*</span><span class="n">tmp_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="n">pivot_pos</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">tmp_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">cumm</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                    <span class="n">cancel</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="k">return</span> <span class="n">sign</span><span class="o">*</span><span class="n">bareiss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">entry</span><span class="p">),</span> <span class="n">pivot_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="n">bareiss</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_eval_det_berkowitz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use the Berkowitz algorithm to compute the determinant.&quot;&quot;&quot;</span>
        <span class="n">berk_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_berkowitz_vector</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">berk_vector</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">berk_vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_eval_det_lu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simpfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the determinant of a matrix from its LU decomposition.</span>
<span class="sd">        This function uses the LU decomposition computed by</span>
<span class="sd">        LUDecomposition_Simple().</span>

<span class="sd">        The keyword arguments iszerofunc and simpfunc are passed to</span>
<span class="sd">        LUDecomposition_Simple().</span>
<span class="sd">        iszerofunc is a callable that returns a boolean indicating if its</span>
<span class="sd">        input is zero, or None if it cannot make the determination.</span>
<span class="sd">        simpfunc is a callable that simplifies its input.</span>
<span class="sd">        The default is simpfunc=None, which indicate that the pivot search</span>
<span class="sd">        algorithm should not attempt to simplify any candidate pivots.</span>
<span class="sd">        If simpfunc fails to simplify its input, then it must return its input</span>
<span class="sd">        instead of a copy.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="c1"># sympy/matrices/tests/test_matrices.py contains a test that</span>
            <span class="c1"># suggests that the determinant of a 0 x 0 matrix is one, by</span>
            <span class="c1"># convention.</span>

        <span class="n">lu</span><span class="p">,</span> <span class="n">row_swaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># P*A = L*U =&gt; det(A) = det(L)*det(U)/det(P) = det(P)*det(U).</span>
        <span class="c1"># Lower triangular factor L encoded in lu has unit diagonal =&gt; det(L) = 1.</span>
        <span class="c1"># P is a permutation matrix =&gt; det(P) in {-1, 1} =&gt; 1/det(P) = det(P).</span>
        <span class="c1"># LUdecomposition_Simple() returns a list of row exchange index pairs, rather</span>
        <span class="c1"># than a permutation matrix, but det(P) = (-1)**len(row_swaps).</span>

        <span class="c1"># Avoid forming the potentially time consuming  product of U&#39;s diagonal entries</span>
        <span class="c1"># if the product is zero.</span>
        <span class="c1"># Bottom right entry of U is 0 =&gt; det(A) = 0.</span>
        <span class="c1"># It may be impossible to determine if this entry of U is zero when it is symbolic.</span>
        <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">lu</span><span class="p">[</span><span class="n">lu</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c1"># Compute det(P)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_swaps</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="c1"># Compute det(U) by calculating the product of U&#39;s diagonal entries.</span>
        <span class="c1"># The upper triangular portion of lu is the upper triangular portion of the</span>
        <span class="c1"># U factor in the LU decomposition.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">det</span> <span class="o">*=</span> <span class="n">lu</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

        <span class="c1"># return det(P)*det(U)</span>
        <span class="k">return</span> <span class="n">det</span>

    <span class="k">def</span> <span class="nf">_eval_determinant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assumed to exist by matrix expressions; If we subclass</span>
<span class="sd">        MatrixDeterminant, we can fully evaluate determinants.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">adjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the adjugate, or classical adjoint, of</span>
<span class="sd">        a matrix.  That is, the transpose of the matrix of cofactors.</span>


<span class="sd">        http://en.wikipedia.org/wiki/Adjugate</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactor_matrix</span>
<span class="sd">        transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactor_matrix</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">charpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;lambda&#39;</span><span class="p">),</span> <span class="n">simplify</span><span class="o">=</span><span class="n">_simplify</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes characteristic polynomial det(x*I - self) where I is</span>
<span class="sd">        the identity matrix.</span>

<span class="sd">        A PurePoly is returned, so using different variables for ``x`` does</span>
<span class="sd">        not affect the comparison or the polynomials:</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 3], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.charpoly(x) == A.charpoly(y)</span>
<span class="sd">        True</span>

<span class="sd">        Specifying ``x`` is optional; a Dummy with name ``lambda`` is used by</span>
<span class="sd">        default (which looks good when pretty-printed in unicode):</span>

<span class="sd">        &gt;&gt;&gt; A.charpoly().as_expr()</span>
<span class="sd">        _lambda**2 - _lambda - 6</span>

<span class="sd">        No test is done to see that ``x`` doesn&#39;t clash with an existing</span>
<span class="sd">        symbol, so using the default (``lambda``) or your own Dummy symbol is</span>
<span class="sd">        the safest option:</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2], [x, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.charpoly().as_expr()</span>
<span class="sd">        _lambda**2 - _lambda - 2*x</span>
<span class="sd">        &gt;&gt;&gt; A.charpoly(x).as_expr()</span>
<span class="sd">        x**2 - 3*x</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The Samuelson-Berkowitz algorithm is used to compute</span>
<span class="sd">        the characteristic polynomial efficiently and without any</span>
<span class="sd">        division operations.  Thus the characteristic polynomial over any</span>
<span class="sd">        commutative ring without zero divisors can be computed.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">berk_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_berkowitz_vector</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">PurePoly</span><span class="p">([</span><span class="n">simplify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">berk_vector</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cofactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the cofactor of an element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactor_matrix</span>
<span class="sd">        minor</span>
<span class="sd">        minor_submatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cofactor_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a matrix containing the cofactor of each element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactor</span>
<span class="sd">        minor</span>
<span class="sd">        minor_submatrix</span>
<span class="sd">        adjugate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                         <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bareiss&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the determinant of a matrix.  If the matrix</span>
<span class="sd">        is at most 3x3, a hard-coded formula is used.</span>
<span class="sd">        Otherwise, the determinant using the method `method`.</span>


<span class="sd">        Possible values for &quot;method&quot;:</span>
<span class="sd">          bareis</span>
<span class="sd">          berkowitz</span>
<span class="sd">          lu</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sanitize `method`</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bareis&quot;</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;bareiss&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;det_lu&quot;</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;lu&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bareiss&quot;</span><span class="p">,</span> <span class="s2">&quot;berkowitz&quot;</span><span class="p">,</span> <span class="s2">&quot;lu&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Determinant method &#39;</span><span class="si">%s</span><span class="s2">&#39; unrecognized&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="c1"># if methods were made internal and all determinant calculations</span>
        <span class="c1"># passed through here, then these lines could be factored out of</span>
        <span class="c1"># the method routines</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>  <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                   <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                   <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                   <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                   <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                   <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bareiss&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_det_bareiss</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;berkowitz&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_det_berkowitz</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lu&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_det_lu</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">minor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the (i,j) minor of `self`.  That is,</span>
<span class="sd">        return the determinant of the matrix obtained by deleting</span>
<span class="sd">        the `i`th row and `j`th column from `self`.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minor_submatrix</span>
<span class="sd">        cofactor</span>
<span class="sd">        det</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_submatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minor_submatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the submatrix obtained by removing the `i`th row</span>
<span class="sd">        and `j`th column from `self`.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minor</span>
<span class="sd">        cofactor</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`i` and `j` must satisfy 0 &lt;= i &lt; `self.rows` &quot;</span>
                             <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="s2">&quot;and 0 &lt;= j &lt; `self.cols` (</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MatrixReductions</span><span class="p">(</span><span class="n">MatrixDeterminant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides basic matrix row/column operations.</span>
<span class="sd">    Should not be instantiated directly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_eval_col_op_swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">col1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">col2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">col2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">col1</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_col_op_multiply_col_by_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_col_op_add_multiple_to_other_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">col2</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_row_op_swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">row1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">row2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">row2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">row1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_row_op_multiply_row_by_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_row_op_add_multiple_to_other_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">row2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_echelon_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (mat, swaps) where `mat` is a row-equivalent matrix</span>
<span class="sd">        in echelon form and `swaps` is a list of row-swaps performed.&quot;&quot;&quot;</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivot_cols</span><span class="p">,</span> <span class="n">swaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_reduce</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">,</span>
                                                      <span class="n">normalize_last</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                      <span class="n">zero_above</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">pivot_cols</span><span class="p">,</span> <span class="n">swaps</span>

    <span class="k">def</span> <span class="nf">_eval_is_echelon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">zeros_below</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">zeros_below</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">_eval_is_echelon</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zeros_below</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">_eval_is_echelon</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_rref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">,</span> <span class="n">normalize_last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivot_cols</span><span class="p">,</span> <span class="n">swaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_reduce</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">,</span>
                                                      <span class="n">normalize_last</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">zero_above</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">pivot_cols</span>

    <span class="k">def</span> <span class="nf">_normalize_op_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">error_str</span><span class="o">=</span><span class="s2">&quot;col&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate the arguments for a row/column operation.  `error_str`</span>
<span class="sd">        can be one of &quot;row&quot; or &quot;col&quot; depending on the arguments being parsed.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">,</span> <span class="s2">&quot;n&lt;-&gt;m&quot;</span><span class="p">,</span> <span class="s2">&quot;n-&gt;n+km&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown </span><span class="si">{}</span><span class="s2"> operation &#39;</span><span class="si">{}</span><span class="s2">&#39;. Valid col operations &quot;</span>
                             <span class="s2">&quot;are &#39;n-&gt;kn&#39;, &#39;n&lt;-&gt;m&#39;, &#39;n-&gt;n+km&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>

        <span class="c1"># normalize and validate the arguments</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">col1</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For a </span><span class="si">{0}</span><span class="s2"> operation &#39;n-&gt;kn&#39; you must provide the &quot;</span>
                                 <span class="s2">&quot;kwargs `</span><span class="si">{0}</span><span class="s2">` and `k`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This matrix doesn&#39;t have a </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n&lt;-&gt;m&quot;</span><span class="p">:</span>
            <span class="c1"># we need two cols to swap. It doesn&#39;t matter</span>
            <span class="c1"># how they were specified, so gather them together and</span>
            <span class="c1"># remove `None`</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># maybe the user left `k` by mistake?</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For a </span><span class="si">{0}</span><span class="s2"> operation &#39;n&lt;-&gt;m&#39; you must provide the &quot;</span>
                                 <span class="s2">&quot;kwargs `</span><span class="si">{0}</span><span class="s2">1` and `</span><span class="si">{0}</span><span class="s2">2`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">))</span>
            <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">cols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This matrix doesn&#39;t have a </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">col1</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This matrix doesn&#39;t have a </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">col2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;n+km&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col1</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">col</span>
            <span class="n">col2</span> <span class="o">=</span> <span class="n">col1</span> <span class="k">if</span> <span class="n">col2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">col2</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">col2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For a </span><span class="si">{0}</span><span class="s2"> operation &#39;n-&gt;n+km&#39; you must provide the &quot;</span>
                                 <span class="s2">&quot;kwargs `</span><span class="si">{0}</span><span class="s2">`, `k`, and `</span><span class="si">{0}</span><span class="s2">2`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="n">col2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For a </span><span class="si">{0}</span><span class="s2"> operation &#39;n-&gt;n+km&#39; `</span><span class="si">{0}</span><span class="s2">` and `</span><span class="si">{0}</span><span class="s2">2` must &quot;</span>
                                 <span class="s2">&quot;be different.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This matrix doesn&#39;t have a </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This matrix doesn&#39;t have a </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_str</span><span class="p">,</span> <span class="n">col2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">op</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span>

    <span class="k">def</span> <span class="nf">_permute_complexity_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Permute columns with complicated elements as</span>
<span class="sd">        far right as they can go.  Since the `sympy` row reduction</span>
<span class="sd">        algorithms start on the left, having complexity right-shifted</span>
<span class="sd">        speeds things up.</span>

<span class="sd">        Returns a tuple (mat, perm) where perm is a permutation</span>
<span class="sd">        of the columns to perform to shift the complex columns right, and mat</span>
<span class="sd">        is the permuted matrix.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">complexity</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># the complexity of a column will be judged by how many</span>
            <span class="c1"># element&#39;s zero-ness cannot be determined</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="nb">complex</span> <span class="o">=</span> <span class="p">[(</span><span class="n">complexity</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)]</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">complex</span><span class="p">)]</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;cols&#39;</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_row_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">,</span> <span class="n">normalize_last</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zero_above</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Row reduce `self` and return a tuple (rref_matrix,</span>
<span class="sd">        pivot_cols, swaps) where pivot_cols are the pivot columns</span>
<span class="sd">        and swaps are any row swaps that were used in the process</span>
<span class="sd">        of row reduction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        iszerofunc : determines if an entry can be used as a pivot</span>
<span class="sd">        simpfunc : used to simplify elements and test if they are</span>
<span class="sd">            zero if `iszerofunc` returns `None`</span>
<span class="sd">        normalize_last : indicates where all row reduction should</span>
<span class="sd">            happen in a fraction-free manner and then the rows are</span>
<span class="sd">            normalized (so that the pivots are 1), or whether</span>
<span class="sd">            rows should be normalized along the way (like the naive</span>
<span class="sd">            row reduction algorithm)</span>
<span class="sd">        normalize : whether pivot rows should be normalized so that</span>
<span class="sd">            the pivot value is 1</span>
<span class="sd">        zero_above : whether entries above the pivot should be zeroed.</span>
<span class="sd">            If `zero_above=False`, an echelon matrix will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_col</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">cols</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">row_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">cols</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">cols</span><span class="p">:(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">cols</span><span class="p">:(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">cols</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">cross_cancel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Does the row op row[i] = a*row[i] - b*row[j]&quot;&quot;&quot;</span>
            <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">mat</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">]</span>

        <span class="n">piv_row</span><span class="p">,</span> <span class="n">piv_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">pivot_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">swaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># use a fraction free method to zero above and below each pivot</span>
        <span class="k">while</span> <span class="n">piv_col</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="ow">and</span> <span class="n">piv_row</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">:</span>
            <span class="n">pivot_offset</span><span class="p">,</span> <span class="n">pivot_val</span><span class="p">,</span> \
            <span class="n">assumed_nonzero</span><span class="p">,</span> <span class="n">newly_determined</span> <span class="o">=</span> <span class="n">_find_reasonable_pivot</span><span class="p">(</span>
                <span class="n">get_col</span><span class="p">(</span><span class="n">piv_col</span><span class="p">)[</span><span class="n">piv_row</span><span class="p">:],</span> <span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">)</span>

            <span class="c1"># _find_reasonable_pivot may have simplified some things</span>
            <span class="c1"># in the process.  Let&#39;s not let them go to waste</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">newly_determined</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">piv_row</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">offset</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">piv_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">if</span> <span class="n">pivot_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">piv_col</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">pivot_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piv_col</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pivot_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">row_swap</span><span class="p">(</span><span class="n">piv_row</span><span class="p">,</span> <span class="n">pivot_offset</span> <span class="o">+</span> <span class="n">piv_row</span><span class="p">)</span>
                <span class="n">swaps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">piv_row</span><span class="p">,</span> <span class="n">pivot_offset</span> <span class="o">+</span> <span class="n">piv_row</span><span class="p">))</span>

            <span class="c1"># if we aren&#39;t normalizing last, we normalize</span>
            <span class="c1"># before we zero the other rows</span>
            <span class="k">if</span> <span class="n">normalize_last</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">piv_row</span><span class="p">,</span> <span class="n">piv_col</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">pivot_val</span>
                <span class="c1"># after normalizing, the pivot value is 1</span>
                <span class="n">pivot_val</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

            <span class="c1"># zero above and below the pivot</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                <span class="c1"># don&#39;t zero our current row</span>
                <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">piv_row</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># don&#39;t zero above the pivot unless we&#39;re told.</span>
                <span class="k">if</span> <span class="n">zero_above</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">piv_row</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># if we&#39;re already a zero, don&#39;t do anything</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">row</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">piv_col</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">cross_cancel</span><span class="p">(</span><span class="n">pivot_val</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">piv_row</span><span class="p">)</span>
            <span class="n">piv_row</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># normalize each row</span>
        <span class="k">if</span> <span class="n">normalize_last</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">piv_i</span><span class="p">,</span> <span class="n">piv_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pivot_cols</span><span class="p">):</span>
                <span class="n">pivot_val</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">piv_i</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">piv_j</span><span class="p">]</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">piv_i</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">piv_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">piv_i</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">piv_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">piv_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">pivot_val</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">mat</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pivot_cols</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">swaps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">echelon_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_pivots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a matrix row-equivalent to `self` that is</span>
<span class="sd">        in echelon form.  Note that echelon form of a matrix</span>
<span class="sd">        is *not* unique, however, properties like the row</span>
<span class="sd">        space and the null space are preserved.&quot;&quot;&quot;</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>

        <span class="n">mat</span><span class="p">,</span> <span class="n">pivots</span><span class="p">,</span> <span class="n">swaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_echelon_form</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_pivots</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="p">,</span> <span class="n">pivots</span>
        <span class="k">return</span> <span class="n">mat</span>

    <span class="k">def</span> <span class="nf">elementary_col_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perfoms the elementary column operation `op`.</span>

<span class="sd">        `op` may be one of</span>

<span class="sd">            * &quot;n-&gt;kn&quot; (column n goes to k*n)</span>
<span class="sd">            * &quot;n&lt;-&gt;m&quot; (swap column n and column m)</span>
<span class="sd">            * &quot;n-&gt;n+km&quot; (column n goes to column n + k*column m)</span>

<span class="sd">        Parameters</span>
<span class="sd">        =========</span>

<span class="sd">        op : string; the elementary row operation</span>
<span class="sd">        col : the column to apply the column operation</span>
<span class="sd">        k : the multiple to apply in the column operation</span>
<span class="sd">        col1 : one column of a column swap</span>
<span class="sd">        col2 : second column of a column swap or column &quot;m&quot; in the column operation</span>
<span class="sd">               &quot;n-&gt;n+km&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_op_args</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">)</span>

        <span class="c1"># now that we&#39;ve validated, we&#39;re all good to dispatch</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_col_op_multiply_col_by_const</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n&lt;-&gt;m&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_col_op_swap</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;n+km&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_col_op_add_multiple_to_other_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">elementary_row_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">row1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">row2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perfoms the elementary row operation `op`.</span>

<span class="sd">        `op` may be one of</span>

<span class="sd">            * &quot;n-&gt;kn&quot; (row n goes to k*n)</span>
<span class="sd">            * &quot;n&lt;-&gt;m&quot; (swap row n and row m)</span>
<span class="sd">            * &quot;n-&gt;n+km&quot; (row n goes to row n + k*row m)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        op : string; the elementary row operation</span>
<span class="sd">        row : the row to apply the row operation</span>
<span class="sd">        k : the multiple to apply in the row operation</span>
<span class="sd">        row1 : one row of a row swap</span>
<span class="sd">        row2 : second row of a row swap or row &quot;m&quot; in the row operation</span>
<span class="sd">               &quot;n-&gt;n+km&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_op_args</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">)</span>

        <span class="c1"># now that we&#39;ve validated, we&#39;re all good to dispatch</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;kn&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_row_op_multiply_row_by_const</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n&lt;-&gt;m&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_row_op_swap</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;n-&gt;n+km&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_row_op_add_multiple_to_other_row</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_echelon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns `True` if he matrix is in echelon form.</span>
<span class="sd">        That is, all rows of zeros are at the bottom, and below</span>
<span class="sd">        each leading non-zero in a row are exclusively zeros.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_echelon</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the rank of a matrix</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([[1, 2], [x, 1 - 1/x]])</span>
<span class="sd">        &gt;&gt;&gt; m.rank()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; n = Matrix(3, 3, range(1, 10))</span>
<span class="sd">        &gt;&gt;&gt; n.rank()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>

        <span class="c1"># for small matrices, we compute the rank explicitly</span>
        <span class="c1"># if is_zero on elements doesn&#39;t answer the question</span>
        <span class="c1"># for small matrices, we fall back to the full routine.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">zeros</span> <span class="ow">and</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="ow">and</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">zeros</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>

        <span class="n">mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_permute_complexity_right</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">)</span>
        <span class="n">echelon_form</span><span class="p">,</span> <span class="n">pivots</span><span class="p">,</span> <span class="n">swaps</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">_eval_echelon_form</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="o">=</span><span class="n">simpfunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pivots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize_last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return reduced row-echelon form of matrix and indices of pivot vars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        iszerofunc : Function</span>
<span class="sd">            A function used for detecting whether an element can</span>
<span class="sd">            act as a pivot.  `lambda x: x.is_zero` is used by default.</span>
<span class="sd">        simplify : Function</span>
<span class="sd">            A function used to simplify elements when looking for a pivot.</span>
<span class="sd">            By default SymPy&#39;s `simplify`is used.</span>
<span class="sd">        pivots : True or False</span>
<span class="sd">            If `True`, a tuple containing the row-reduced matrix and a tuple</span>
<span class="sd">            of pivot columns is returned.  If `False` just the row-reduced</span>
<span class="sd">            matrix is returned.</span>
<span class="sd">        normalize_last : True or False</span>
<span class="sd">            If `True`, no pivots are normalized to `1` until after all entries</span>
<span class="sd">            above and below each pivot are zeroed.  This means the row</span>
<span class="sd">            reduction algorithm is fraction free until the very last step.</span>
<span class="sd">            If `False`, the naive row reduction procedure is used where</span>
<span class="sd">            each pivot is normalized to be `1` before row operations are</span>
<span class="sd">            used to zero above and below the pivot.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The default value of `normalize_last=True` can provide significant</span>
<span class="sd">        speedup to row reduction, especially on matrices with symbols.  However,</span>
<span class="sd">        if you depend on the form row reduction algorithm leaves entries</span>
<span class="sd">        of the matrix, set `noramlize_last=False`</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([[1, 2], [x, 1 - 1/x]])</span>
<span class="sd">        &gt;&gt;&gt; m.rref()</span>
<span class="sd">        (Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1]]), (0, 1))</span>
<span class="sd">        &gt;&gt;&gt; rref_matrix, rref_pivots = m.rref()</span>
<span class="sd">        &gt;&gt;&gt; rref_matrix</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; rref_pivots</span>
<span class="sd">        (0, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>

        <span class="n">ret</span><span class="p">,</span> <span class="n">pivot_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_rref</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span>
                                          <span class="n">simpfunc</span><span class="o">=</span><span class="n">simpfunc</span><span class="p">,</span>
                                          <span class="n">normalize_last</span><span class="o">=</span><span class="n">normalize_last</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pivots</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">pivot_cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">MatrixSubspaces</span><span class="p">(</span><span class="n">MatrixReductions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides methods relating to the fundamental subspaces</span>
<span class="sd">    of a matrix.  Should not be instantiated directly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">columnspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of vectors (Matrix objects) that span columnspace of self</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 1,  3, 0],</span>
<span class="sd">        [-2, -6, 0],</span>
<span class="sd">        [ 3,  9, 6]])</span>
<span class="sd">        &gt;&gt;&gt; m.columnspace()</span>
<span class="sd">        [Matrix([</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [-2],</span>
<span class="sd">        [ 3]]), Matrix([</span>
<span class="sd">        [0],</span>
<span class="sd">        [0],</span>
<span class="sd">        [6]])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        nullspace</span>
<span class="sd">        rowspace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">with_pivots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">nullspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of vectors (Matrix objects) that span nullspace of self</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 1,  3, 0],</span>
<span class="sd">        [-2, -6, 0],</span>
<span class="sd">        [ 3,  9, 6]])</span>
<span class="sd">        &gt;&gt;&gt; m.nullspace()</span>
<span class="sd">        [Matrix([</span>
<span class="sd">        [-3],</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [ 0]])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        columnspace</span>
<span class="sd">        rowspace</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>

        <span class="n">free_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">]</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">free_var</span> <span class="ow">in</span> <span class="n">free_vars</span><span class="p">:</span>
            <span class="c1"># for each free variable, we will set it to 1 and all others</span>
            <span class="c1"># to 0.  Then, we will use back substitution to solve the system</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">free_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">for</span> <span class="n">piv_row</span><span class="p">,</span> <span class="n">piv_col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pivots</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">[</span><span class="n">piv_row</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">free_var</span><span class="p">,):</span>
                    <span class="n">vec</span><span class="p">[</span><span class="n">piv_col</span><span class="p">]</span> <span class="o">-=</span> <span class="n">reduced</span><span class="p">[</span><span class="n">piv_row</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
            <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rowspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of vectors that span the row space of self.&quot;&quot;&quot;</span>

        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">with_pivots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">reduced</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">))]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">orthogonalize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">vecs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the Gram-Schmidt orthogonalization procedure</span>
<span class="sd">        to vectors supplied in `vecs`.</span>

<span class="sd">        Arguments</span>
<span class="sd">        =========</span>

<span class="sd">        vecs : vectors to be made orthogonal</span>
<span class="sd">        normalize : bool. Whether the returned vectors</span>
<span class="sd">                    should be renormalized to be unit vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">normalize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;normalize&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">perp_to_subspace</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;projects vec onto the subspace given</span>
<span class="sd">            by the orthogonal basis `basis`&quot;&quot;&quot;</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">project</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vec</span>
            <span class="k">return</span> <span class="n">vec</span> <span class="o">-</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># make sure we start with a non-zero vector</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">vecs</span><span class="p">:</span>
            <span class="n">perp</span> <span class="o">=</span> <span class="n">perp_to_subspace</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">perp</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">vec</span> <span class="o">/</span> <span class="n">vec</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">MatrixEigen</span><span class="p">(</span><span class="n">MatrixSubspaces</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides basic matrix eigenvalue/vector operations.</span>
<span class="sd">    Should not be instantiated directly.&quot;&quot;&quot;</span>

    <span class="n">_cache_is_diagonalizable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_cache_eigenvects</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">diagonalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (P, D), where D is diagonal and</span>

<span class="sd">            D = P^-1 * M * P</span>

<span class="sd">        where M is current matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        reals_only : bool. Whether to throw an error if complex numbers are need</span>
<span class="sd">                     to diagonalize. (Default: False)</span>
<span class="sd">        sort : bool. Sort the eigenvalues along the diagonal. (Default: False)</span>
<span class="sd">        normalize : bool. If True, normalize the columns of P. (Default: False)</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1,  2, 0],</span>
<span class="sd">        [0,  3, 0],</span>
<span class="sd">        [2, -4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; (P, D) = m.diagonalize()</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 2, 0],</span>
<span class="sd">        [0, 0, 3]])</span>
<span class="sd">        &gt;&gt;&gt; P</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-1, 0, -1],</span>
<span class="sd">        [ 0, 0, -1],</span>
<span class="sd">        [ 2, 1,  2]])</span>
<span class="sd">        &gt;&gt;&gt; P.inv() * m * P</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 2, 0],</span>
<span class="sd">        [0, 0, 3]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_diagonal</span>
<span class="sd">        is_diagonalizable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonalizable</span><span class="p">(</span><span class="n">reals_only</span><span class="o">=</span><span class="n">reals_only</span><span class="p">,</span> <span class="n">clear_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix is not diagonalizable&quot;</span><span class="p">)</span>

        <span class="n">eigenvecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_eigenvects</span>
        <span class="k">if</span> <span class="n">eigenvecs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eigenvecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">eigenvecs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eigenvecs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="n">p_cols</span><span class="p">,</span> <span class="n">diag</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="n">eigenvecs</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">+=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="n">p_cols</span> <span class="o">+=</span> <span class="n">basis</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">p_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">/</span> <span class="n">v</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p_cols</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="o">*</span><span class="n">p_cols</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">diag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eigenvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_when_incomplete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return eigenvalues using the Berkowitz agorithm to compute</span>
<span class="sd">        the characteristic polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        error_when_incomplete : bool</span>
<span class="sd">            Raise an error when not all eigenvalues are computed. This is</span>
<span class="sd">            caused by ``roots`` not returning a full list of eigenvalues.</span>

<span class="sd">        Since the roots routine doesn&#39;t always work well with Floats,</span>
<span class="sd">        they will be replaced with Rationals before calling that</span>
<span class="sd">        routine. If this is not desired, set flag ``rational`` to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mat</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># pop unsupported flag</span>
        <span class="n">eigs</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)),</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># make sure the algebraic multiplicty sums to the</span>
        <span class="c1"># size of the matrix</span>
        <span class="k">if</span> <span class="n">error_when_incomplete</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">eigs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;Could not compute eigenvalues for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">eigs</span>

    <span class="k">def</span> <span class="nf">eigenvects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_when_incomplete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of triples (eigenval, multiplicity, basis).</span>

<span class="sd">        The flag ``simplify`` has two effects:</span>
<span class="sd">            1) if bool(simplify) is True, as_content_primitive()</span>
<span class="sd">            will be used to tidy up normalization artifacts;</span>
<span class="sd">            2) if nullspace needs simplification to compute the</span>
<span class="sd">            basis, the simplify flag will be passed on to the</span>
<span class="sd">            nullspace routine which will interpret it there.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        error_when_incomplete : bool</span>
<span class="sd">            Raise an error when not all eigenvalues are computed. This is</span>
<span class="sd">            caused by ``roots`` not returning a full list of eigenvalues.</span>

<span class="sd">        If the matrix contains any Floats, they will be changed to Rationals</span>
<span class="sd">        for computation purposes, but the answers will be returned after being</span>
<span class="sd">        evaluated with evalf. If it is desired to removed small imaginary</span>
<span class="sd">        portions during the evalf step, pass a value for the ``chop`` flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">eye</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">):</span>
            <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">_simplify</span> <span class="k">if</span> <span class="n">simplify</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="n">primitive</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">chop</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;chop&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;multiple&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># remove this if it&#39;s there</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># roots doesn&#39;t like Floats, so replace them with Rationals</span>
        <span class="n">has_floats</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_floats</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">eigenspace</span><span class="p">(</span><span class="n">eigenval</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Get a basis for the eigenspace for a particular eigenvalue&quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="n">eigenval</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
            <span class="c1"># the nullspace for a real eigenvalue should be</span>
            <span class="c1"># non-trivial.  If we didn&#39;t find an eigenvector, try once</span>
            <span class="c1"># more a little harder</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nullspace</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Can&#39;t evaluate eigenvector for eigenvalue </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">eigenval</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">error_when_incomplete</span><span class="o">=</span><span class="n">error_when_incomplete</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">eigenspace</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="n">eigenvals</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">primitive</span><span class="p">:</span>
            <span class="c1"># if the primitive flag is set, get rid of any common</span>
            <span class="c1"># integer denominators</span>
            <span class="k">def</span> <span class="nf">denom_clean</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">gcd</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">v</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">simpfunc</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">denom_clean</span><span class="p">(</span><span class="n">es</span><span class="p">))</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">has_floats</span><span class="p">:</span>
            <span class="c1"># if we had floats to start with, turn the eigenvectors to floats</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[(</span><span class="n">val</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="n">chop</span><span class="p">),</span> <span class="n">mult</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="n">chop</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">es</span><span class="p">])</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">is_diagonalizable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if a matrix is diagonalizable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        reals_only : bool. If reals_only=True, determine whether the matrix can be</span>
<span class="sd">                     diagonalized without complex numbers. (Default: False)</span>

<span class="sd">        kwargs</span>
<span class="sd">        ======</span>

<span class="sd">        clear_cache : bool. If True, clear the result of any computations when finished.</span>
<span class="sd">                      (Default: True)</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1,  2, 0],</span>
<span class="sd">        [0,  3, 0],</span>
<span class="sd">        [2, -4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1],</span>
<span class="sd">        [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, -1, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 0, 1],</span>
<span class="sd">        [-1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable(reals_only=True)</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_diagonal</span>
<span class="sd">        diagonalize</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">clear_cache</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clear_cache&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;clear_subproducts&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">clear_cache</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clear_subproducts&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">cleanup</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Clears any cached values if requested&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">clear_cache</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_eigenvects</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_is_diagonalizable</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="n">cleanup</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># use the cached value if we have it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_is_diagonalizable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_is_diagonalizable</span>
            <span class="n">cleanup</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">is_real</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="c1"># every real symmetric matrix is real diagonalizable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache_is_diagonalizable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">cleanup</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_eigenvects</span><span class="p">:</span>
            <span class="c1"># if we have a complex eigenvalue</span>
            <span class="k">if</span> <span class="n">reals_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if the geometric multiplicity doesn&#39;t equal the algebraic</span>
            <span class="k">if</span> <span class="n">mult</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">cleanup</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">jordan_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transform</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `(P, J)` where `J` is a Jordan block</span>
<span class="sd">        matrix and `P` is a matrix such that</span>

<span class="sd">            `self == P*J*P**-1`</span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        calc_transform : bool</span>
<span class="sd">            If ``False``, then only `J` is returned.</span>
<span class="sd">        chop : bool</span>
<span class="sd">            All matrices are convered to exact types when computing</span>
<span class="sd">            eigenvalues and eigenvectors.  As a result, there may be</span>
<span class="sd">            approximation errors.  If ``chop==True``, these errors</span>
<span class="sd">            will be truncated.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([[ 6,  5, -2, -3], [-3, -1,  3,  3], [ 2,  1, -2, -3], [-1,  1,  5,  5]])</span>
<span class="sd">        &gt;&gt;&gt; P, J = m.jordan_form()</span>
<span class="sd">        &gt;&gt;&gt; J</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 1, 0, 0],</span>
<span class="sd">        [0, 2, 0, 0],</span>
<span class="sd">        [0, 0, 2, 1],</span>
<span class="sd">        [0, 0, 0, 2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        jordan_block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Only square matrices have Jordan forms&quot;</span><span class="p">)</span>

        <span class="n">chop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;chop&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">has_floats</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">restore_floats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;If `has_floats` is `True`, cast all `args` as</span>
<span class="sd">            matrices of floats.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">has_floats</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="n">chop</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">args</span>

        <span class="c1"># cache calculations for some speedup</span>
        <span class="n">mat_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">def</span> <span class="nf">eig_mat</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Cache computations of (self - val*I)**pow for quick</span>
<span class="sd">            retrieval&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">)</span> <span class="ow">in</span> <span class="n">mat_cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">mat_cache</span><span class="p">:</span>
                <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span> <span class="o">-</span> <span class="n">val</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span><span class="o">**</span><span class="nb">pow</span>
            <span class="k">return</span> <span class="n">mat_cache</span><span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="nb">pow</span><span class="p">)]</span>

        <span class="c1"># helper functions</span>
        <span class="k">def</span> <span class="nf">nullity_chain</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate the sequence  [0, nullity(E), nullity(E**2), ...]</span>
<span class="sd">            until it is constant where `E = self - val*I`&quot;&quot;&quot;</span>
            <span class="c1"># mat.rank() is faster than computing the null space,</span>
            <span class="c1"># so use the rank-nullity theorem</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nullity</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">-</span> <span class="n">eig_mat</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">while</span> <span class="n">nullity</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nullity</span><span class="p">)</span>
                <span class="n">nullity</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">-</span> <span class="n">eig_mat</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">def</span> <span class="nf">blocks_from_nullity_chain</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return a list of the size of each Jordan block.</span>
<span class="sd">            If d_n is the nullity of E**n, then the number</span>
<span class="sd">            of Jordan blocks of size n is</span>

<span class="sd">                2*d_n - d_(n-1) - d_(n+1)&quot;&quot;&quot;</span>
            <span class="c1"># d[0] is always the number of columns, so skip past it</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="c1"># d is assumed to plateau with &quot;d[ len(d) ] == d[-1]&quot;, so</span>
            <span class="c1"># 2*d_n - d_(n-1) - d_(n+1) == d_n - d_(n-1)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">end</span>

        <span class="k">def</span> <span class="nf">pick_vec</span><span class="p">(</span><span class="n">small_basis</span><span class="p">,</span> <span class="n">big_basis</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Picks a vector from big_basis that isn&#39;t in</span>
<span class="sd">            the subspace spanned by small_basis&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">small_basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">big_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">big_basis</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">small_basis</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">echelon_form</span><span class="p">(</span><span class="n">with_pivots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pivots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">small_basis</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">v</span>

        <span class="c1"># roots doesn&#39;t like Floats, so replace them with Rationals</span>
        <span class="k">if</span> <span class="n">has_floats</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># first calculate the jordan block structure</span>
        <span class="n">eigs</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>

        <span class="c1"># make sure that we found all the roots by counting</span>
        <span class="c1"># the algebraic multiplicity</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">eigs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;Could not compute eigenvalues for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span>

        <span class="c1"># most matrices have distinct eigenvalues</span>
        <span class="c1"># and so are diagonalizable.  In this case, don&#39;t</span>
        <span class="c1"># do extra work!</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">eigs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">))</span>
            <span class="n">jordan_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">calc_transform</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">restore_floats</span><span class="p">(</span><span class="n">jordan_mat</span><span class="p">)</span>
            <span class="n">jordan_basis</span> <span class="o">=</span> <span class="p">[</span><span class="n">eig_mat</span><span class="p">(</span><span class="n">eig</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">]</span>
            <span class="n">basis_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="o">*</span><span class="n">jordan_basis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">restore_floats</span><span class="p">(</span><span class="n">basis_mat</span><span class="p">,</span> <span class="n">jordan_mat</span><span class="p">)</span>

        <span class="n">block_structure</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eigs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">):</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">nullity_chain</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span>
            <span class="n">block_sizes</span> <span class="o">=</span> <span class="n">blocks_from_nullity_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
            <span class="c1"># if block_sizes == [a, b, c, ...], then the number of</span>
            <span class="c1"># Jordan blocks of size 1 is a, of size 2 is b, etc.</span>
            <span class="c1"># create an array that has (eig, block_size) with one</span>
            <span class="c1"># entry for each block</span>
            <span class="n">size_nums</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block_sizes</span><span class="p">)]</span>
            <span class="c1"># we expect larger Jordan blocks to come earlier</span>
            <span class="n">size_nums</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="n">block_structure</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span><span class="n">eig</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">size</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">size_nums</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">jordan_block</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="o">=</span><span class="n">eig</span><span class="p">)</span> <span class="k">for</span> <span class="n">eig</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">block_structure</span><span class="p">)</span>
        <span class="n">jordan_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">calc_transform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">restore_floats</span><span class="p">(</span><span class="n">jordan_mat</span><span class="p">)</span>

        <span class="c1"># For each generalized eigenspace, calculate a basis.</span>
        <span class="c1"># We start by looking for a vector in null( (A - eig*I)**n )</span>
        <span class="c1"># which isn&#39;t in null( (A - eig*I)**(n-1) ) where n is</span>
        <span class="c1"># the size of the Jordan block</span>
        <span class="c1">#</span>
        <span class="c1"># Ideally we&#39;d just loop through block_structure and</span>
        <span class="c1"># compute each generalized eigenspace.  However, this</span>
        <span class="c1"># causes a lot of unneeded computation.  Instead, we</span>
        <span class="c1"># go through the eigenvalues separately, since we know</span>
        <span class="c1"># their generalized eigenspaces must have bases that</span>
        <span class="c1"># are linearly independent.</span>
        <span class="n">jordan_basis</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eigs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">):</span>
            <span class="n">eig_basis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">block_eig</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">block_structure</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block_eig</span> <span class="o">!=</span> <span class="n">eig</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">null_big</span> <span class="o">=</span> <span class="p">(</span><span class="n">eig_mat</span><span class="p">(</span><span class="n">eig</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
                <span class="n">null_small</span> <span class="o">=</span> <span class="p">(</span><span class="n">eig_mat</span><span class="p">(</span><span class="n">eig</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
                <span class="c1"># we want to pick something that is in the big basis</span>
                <span class="c1"># and not the small, but also something that is independent</span>
                <span class="c1"># of any other generalized eigenvectors from a different</span>
                <span class="c1"># generalized eigenspace sharing the same eigenvalue.</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">pick_vec</span><span class="p">(</span><span class="n">null_small</span> <span class="o">+</span> <span class="n">eig_basis</span><span class="p">,</span> <span class="n">null_big</span><span class="p">)</span>
                <span class="n">new_vecs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">eig_mat</span><span class="p">(</span><span class="n">eig</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="n">vec</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
                <span class="n">eig_basis</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_vecs</span><span class="p">)</span>
                <span class="n">jordan_basis</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">new_vecs</span><span class="p">))</span>

        <span class="n">basis_mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="o">*</span><span class="n">jordan_basis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">restore_floats</span><span class="p">(</span><span class="n">basis_mat</span><span class="p">,</span> <span class="n">jordan_mat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">left_eigenvects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns left eigenvectors and eigenvalues.</span>

<span class="sd">        This function returns the list of triples (eigenval, multiplicity,</span>
<span class="sd">        basis) for the left eigenvectors. Options are the same as for</span>
<span class="sd">        eigenvects(), i.e. the ``**flags`` arguments gets passed directly to</span>
<span class="sd">        eigenvects().</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[0, 1, 1], [1, 0, 0], [1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; M.eigenvects()</span>
<span class="sd">        [(-1, 1, [Matrix([</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [ 0]])]), (0, 1, [Matrix([</span>
<span class="sd">        [ 0],</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 1]])]), (2, 1, [Matrix([</span>
<span class="sd">        [2/3],</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [  1]])])]</span>
<span class="sd">        &gt;&gt;&gt; M.left_eigenvects()</span>
<span class="sd">        [(-1, 1, [Matrix([[-2, 1, 1]])]), (0, 1, [Matrix([[-1, -1, 1]])]), (2,</span>
<span class="sd">        1, [Matrix([[1, 1, 1]])])]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[(</span><span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">])</span> <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="n">eigs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the singular values of a Matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Symbol</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.singular_values()</span>
<span class="sd">        [sqrt(x**2 + 1), 1, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        condition_number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Compute eigenvalues of A.H A</span>
        <span class="n">valmultpairs</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>

        <span class="c1"># Expands result from eigenvals into a simple list</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">valmultpairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">*</span> <span class="n">v</span>  <span class="c1"># dangerous! same k in several spots!</span>
        <span class="c1"># sort them in descending order</span>
        <span class="n">vals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vals</span>



<span class="k">class</span> <span class="nc">MatrixCalculus</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides calculus-related matrix operations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the derivative of each element in the matrix.</span>
<span class="sd">        ``args`` will be passed to the ``integrate`` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.diff(x)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        integrate</span>
<span class="sd">        limit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate each element of the matrix.  ``args`` will</span>
<span class="sd">        be passed to the ``integrate`` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.integrate((x, ))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [x**2/2, x*y],</span>
<span class="sd">        [     x,   0]])</span>
<span class="sd">        &gt;&gt;&gt; M.integrate((x, 0, 2))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 2*y],</span>
<span class="sd">        [2,   0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        limit</span>
<span class="sd">        diff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the Jacobian matrix (derivative of a vector-valued function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        self : vector of expressions representing functions f_i(x_1, ..., x_n).</span>
<span class="sd">        X : set of x_i&#39;s in order, it can be a list or a Matrix</span>

<span class="sd">        Both self and X can be a row or a column matrix in any order</span>
<span class="sd">        (i.e., jacobian() should always work).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos, Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import rho, phi</span>
<span class="sd">        &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])</span>
<span class="sd">        &gt;&gt;&gt; Y = Matrix([rho, phi])</span>
<span class="sd">        &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [cos(phi), -rho*sin(phi)],</span>
<span class="sd">        [sin(phi),  rho*cos(phi)],</span>
<span class="sd">        [   2*rho,             0]])</span>
<span class="sd">        &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi)])</span>
<span class="sd">        &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [cos(phi), -rho*sin(phi)],</span>
<span class="sd">        [sin(phi),  rho*cos(phi)]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        hessian</span>
<span class="sd">        wronskian</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># Both X and self can be a row or a column matrix, so we need to make</span>
        <span class="c1"># sure all valid combinations work, but everything else fails:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;self must be a row or a column matrix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;X must be a row or a column matrix&quot;</span><span class="p">)</span>

        <span class="c1"># m is the number of functions and n is the number of variables</span>
        <span class="c1"># computing the Jacobian is now easy:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the limit of each element in the matrix.</span>
<span class="sd">        ``args`` will be passed to the ``limit`` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.limit(x, 2)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, y],</span>
<span class="sd">        [1, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        integrate</span>
<span class="sd">        diff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="c1"># https://github.com/sympy/sympy/pull/12854</span>
<span class="k">class</span> <span class="nc">MatrixDeprecated</span><span class="p">(</span><span class="n">MatrixCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to house deprecated matrix methods.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">berkowitz_charpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;lambda&#39;</span><span class="p">),</span> <span class="n">simplify</span><span class="o">=</span><span class="n">_simplify</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">berkowitz_det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes determinant using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;berkowitz&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">berkowitz_eigenvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes eigenvalues of a Matrix using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">berkowitz_minors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes principal minors using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">minors</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">():</span>
            <span class="n">minors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">minors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">berkowitz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">zeros</span>
        <span class="n">berk</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">berk</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">T</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">B</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">items</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">transforms</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transforms</span><span class="p">):</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">berk</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">polys</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">cofactorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactor_matrix</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">det_bareis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bareiss&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">det_bareiss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using Bareiss&#39; fraction-free</span>
<span class="sd">        algorithm which is an extension of the well known Gaussian</span>
<span class="sd">        elimination method. This approach is best suited for dense</span>
<span class="sd">        symbolic matrices and will result in a determinant with</span>
<span class="sd">        minimal number of fractions. It means that less term</span>
<span class="sd">        rewriting is needed on resulting formulae.</span>

<span class="sd">        TODO: Implement algorithm for sparse matrices (SFF),</span>
<span class="sd">        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        berkowitz_det</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bareiss&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">det_LU_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using LU decomposition</span>


<span class="sd">        Note that this method fails if the LU decomposition itself</span>
<span class="sd">        fails. In particular, if the matrix has no inverse this method</span>
<span class="sd">        will fail.</span>

<span class="sd">        TODO: Implement algorithm for sparse matrices (SFF),</span>
<span class="sd">        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>


<span class="sd">        det</span>
<span class="sd">        det_bareiss</span>
<span class="sd">        berkowitz_det</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;lu&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">jordan_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_block</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">eigenvalue</span><span class="o">=</span><span class="n">eigenval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">jordan_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transformation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_form</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">get_diag_blocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">minorEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minor_submatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">permuteBkwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Permute the rows of the matrix with the given permutation in reverse.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">permuteFwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Permute the rows of the matrix with the given permutation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="MatrixBase"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase">[docs]</a><span class="k">class</span> <span class="nc">MatrixBase</span><span class="p">(</span><span class="n">MatrixDeprecated</span><span class="p">,</span>
                 <span class="n">MatrixCalculus</span><span class="p">,</span>
                 <span class="n">MatrixEigen</span><span class="p">,</span>
                 <span class="n">MatrixCommon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for matrix objects.&quot;&quot;&quot;</span>
    <span class="c1"># Added just for numpy compatibility</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">11</span>

    <span class="n">is_Matrix</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_class_priority</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">_sympify</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sympify</span><span class="p">)</span>

    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Mutable</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="k">import</span> <span class="n">matrix2numpy</span>
        <span class="k">return</span> <span class="n">matrix2numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;integrate&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="n">item_doit</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">attr</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">item_doit</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">doit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no attribute </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of elements of self.</span>

<span class="sd">        Implemented mainly so bool(Matrix()) == False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

    <span class="k">def</span> <span class="nf">__mathml__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mml</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s2">&quot;&lt;matrixrow&gt;&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">mml</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">__mathml__</span><span class="p">()</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s2">&quot;&lt;/matrixrow&gt;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;matrix&gt;&quot;</span> <span class="o">+</span> <span class="n">mml</span> <span class="o">+</span> <span class="s2">&quot;&lt;/matrix&gt;&quot;</span>

    <span class="c1"># needed for python 2 compatibility</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_matrix_pow_by_jordan_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">diag</span><span class="p">,</span> <span class="n">MutableMatrix</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">binomial</span>

        <span class="k">def</span> <span class="nf">jordan_cell_power</span><span class="p">(</span><span class="n">jc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">jc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">jc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-integer power cannot be evaluated&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">bn</span> <span class="o">=</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">binomial</span><span class="p">):</span>
                        <span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">_eval_expand_func</span><span class="p">()</span>
                    <span class="n">jc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">bn</span>

        <span class="n">P</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_form</span><span class="p">()</span>
        <span class="n">jordan_cells</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">get_diag_blocks</span><span class="p">()</span>
        <span class="c1"># Make sure jordan_cells matrices are mutable:</span>
        <span class="n">jordan_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">MutableMatrix</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jordan_cells</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jordan_cells</span><span class="p">:</span>
            <span class="n">jordan_cell_power</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">jordan_cells</span><span class="p">)</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Matrix(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">, [])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Matrix(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_diagonalize_clear_subproducts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symbolic</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetric</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">printer</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.str</span> <span class="k">import</span> <span class="n">StrPrinter</span>
            <span class="n">printer</span> <span class="o">=</span> <span class="n">StrPrinter</span><span class="p">()</span>
        <span class="c1"># Handle zero dimensions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Matrix(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">, [])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Matrix([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Matrix([</span><span class="se">\n</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_creation_inputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rows, cols and flat matrix elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>

<span class="sd">        Matrix can be constructed as follows:</span>

<span class="sd">        * from a nested list of iterables</span>

<span class="sd">        &gt;&gt;&gt; Matrix( ((1, 2+I), (3, 4)) )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [3,     4]])</span>

<span class="sd">        * from un-nested iterable (interpreted as a column)</span>

<span class="sd">        &gt;&gt;&gt; Matrix( [1, 2] )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1],</span>
<span class="sd">        [2]])</span>

<span class="sd">        * from un-nested iterable with dimensions</span>

<span class="sd">        &gt;&gt;&gt; Matrix(1, 2, [1, 2] )</span>
<span class="sd">        Matrix([[1, 2]])</span>

<span class="sd">        * from no arguments (a 0 x 0 matrix)</span>

<span class="sd">        &gt;&gt;&gt; Matrix()</span>
<span class="sd">        Matrix(0, 0, [])</span>

<span class="sd">        * from a rule</span>

<span class="sd">        &gt;&gt;&gt; Matrix(2, 2, lambda i, j: i/(j + 1) )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0,   0],</span>
<span class="sd">        [1, 1/2]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices.sparse</span> <span class="k">import</span> <span class="n">SparseMatrix</span>

        <span class="n">flat_list</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Matrix(SparseMatrix(...))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SparseMatrix</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="c1"># Matrix(Matrix(...))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MatrixBase</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_mat</span>

            <span class="c1"># Matrix(MatrixSymbol(&#39;X&#39;, 2, 2))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_explicit</span><span class="p">()</span><span class="o">.</span><span class="n">_mat</span>

            <span class="c1"># Matrix(numpy.ones((2, 2)))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__array__&quot;</span><span class="p">):</span>
                <span class="c1"># NumPy array or matrix or some other object that implements</span>
                <span class="c1"># __array__. So let&#39;s first use this method to get a</span>
                <span class="c1"># numpy.array() and then make a python list out of it.</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>
                    <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                        <span class="n">flat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;SymPy supports just 1D and 2D matrices&quot;</span><span class="p">)</span>

            <span class="c1"># Matrix([1, 2, 3]) or Matrix([[1, 2], [3, 4]])</span>
            <span class="k">elif</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DeferredVector</span><span class="p">):</span>
                <span class="n">in_mat</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ncol</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
                        <span class="n">in_mat</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">cols</span> <span class="ow">or</span> <span class="n">row</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>  <span class="c1"># only pay attention if it&#39;s not 0x0</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">in_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got rows of variable lengths: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                     <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">ncol</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_mat</span><span class="p">)</span> <span class="k">if</span> <span class="n">cols</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">in_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">cols</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">in_mat</span><span class="p">]</span>
                        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                        <span class="n">flat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">in_mat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cols</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create a </span><span class="si">{}</span><span class="s2"> x </span><span class="si">{}</span><span class="s2"> matrix. &quot;</span>
                                 <span class="s2">&quot;Both dimensions must be positive&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

            <span class="c1"># Matrix(2, 2, lambda i, j: i+j)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">flat_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
                         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">)])</span>

            <span class="c1"># Matrix(2, 2, [1, 2, 3, 4])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_list</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;List length should be equal to rows*columns&#39;</span><span class="p">)</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flat_list</span><span class="p">]</span>


        <span class="c1"># Matrix()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Empty Matrix</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">flat_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data type not understood&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>

    <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper to set value at location given by key.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I, zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(((1, 2+I), (3, 4)))</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [3,     4]])</span>
<span class="sd">        &gt;&gt;&gt; m[1, 0] = 9</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [9,     4]])</span>
<span class="sd">        &gt;&gt;&gt; m[1, 0] = [[0, 1]]</span>

<span class="sd">        To replace row r you assign to position r*m where m</span>
<span class="sd">        is the number of columns:</span>

<span class="sd">        &gt;&gt;&gt; M = zeros(4)</span>
<span class="sd">        &gt;&gt;&gt; m = M.cols</span>
<span class="sd">        &gt;&gt;&gt; M[3*m] = ones(1, m)*2; M</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [2, 2, 2, 2]])</span>

<span class="sd">        And to replace column c you can assign to position c:</span>

<span class="sd">        &gt;&gt;&gt; M[2] = ones(m, 1)*4; M</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [2, 2, 4, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="k">import</span> <span class="n">Matrix</span>

        <span class="n">is_slice</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key2ij</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">is_mat</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_mat</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_list</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unexpected value: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_mat</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">is_mat</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">is_mat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_slice</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)),</span>
                           <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span>
                           <span class="nb">slice</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

<div class="viewcode-block" id="MatrixBase.add"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self + b &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">b</span></div>

<div class="viewcode-block" id="MatrixBase.cholesky_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.cholesky_solve">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B using Cholesky decomposition,</span>
<span class="sd">        for a general square non-singular matrix.</span>
<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Under-determined System. &#39;</span>
                                      <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.cholesky"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.cholesky">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Cholesky decomposition L of a matrix A</span>
<span class="sd">        such that L * L.T = A</span>

<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 5, 0, 0],</span>
<span class="sd">        [ 3, 3, 0],</span>
<span class="sd">        [-1, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky() * A.cholesky().T</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [25, 15, -5],</span>
<span class="sd">        [15, 18,  0],</span>
<span class="sd">        [-5,  0, 11]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LDLdecomposition</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.condition_number"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.condition_number">[docs]</a>    <span class="k">def</span> <span class="nf">condition_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the condition number of a matrix.</span>

<span class="sd">        This is the maximum singular value divided by the minimum singular value</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, S</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])</span>
<span class="sd">        &gt;&gt;&gt; A.condition_number()</span>
<span class="sd">        100</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        singular_values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">singularvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span> <span class="o">/</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.copy"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the copy of a matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(2, 2, [1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A.copy()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2],</span>
<span class="sd">        [3, 4]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.cross"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cross product of `self` and `b` relaxing the condition</span>
<span class="sd">        of compatible dimensions: if each has 3 elements, a matrix of the</span>
<span class="sd">        same type and shape as `self` will be returned. If `b` has the same</span>
<span class="sd">        shape as `self` then common identities for the cross product (like</span>
<span class="sd">        `a x b = - b x a`) will hold.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        dot</span>
<span class="sd">        multiply</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Dimensions incorrect for cross product: </span><span class="si">%s</span><span class="s2"> x </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Dirac conjugate (if self.rows == 4).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I, eye</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix((0, 1 + I, 2, 3))</span>
<span class="sd">        &gt;&gt;&gt; m.D</span>
<span class="sd">        Matrix([[0, 1 - I, -2, -3]])</span>
<span class="sd">        &gt;&gt;&gt; m = (eye(4) + I*eye(4))</span>
<span class="sd">        &gt;&gt;&gt; m[0, 3] = 2</span>
<span class="sd">        &gt;&gt;&gt; m.D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1 - I,     0,      0,      0],</span>
<span class="sd">        [    0, 1 - I,      0,      0],</span>
<span class="sd">        [    0,     0, -1 + I,      0],</span>
<span class="sd">        [    2,     0,      0, -1 + I]])</span>

<span class="sd">        If the matrix does not have 4 rows an AttributeError will be raised</span>
<span class="sd">        because this property is only defined for matrices with 4 rows.</span>

<span class="sd">        &gt;&gt;&gt; Matrix(eye(2)).D</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: Matrix has no attribute D.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        conjugate: By-element conjugation</span>
<span class="sd">        H: Hermite conjugation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.physics.matrices</span> <span class="k">import</span> <span class="n">mgamma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># In Python 3.2, properties can only return an AttributeError</span>
            <span class="c1"># so we can&#39;t raise a ShapeError -- see commit which added the</span>
            <span class="c1"># first line of this inline comment. Also, there is no need</span>
            <span class="c1"># for a message since MatrixBase will raise the AttributeError</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">mgamma</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="MatrixBase.diagonal_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.diagonal_solve">[docs]</a>    <span class="k">def</span> <span class="nf">diagonal_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B efficiently, where A is a diagonal Matrix,</span>
<span class="sd">        with non-zero diagonal entries.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = eye(2)*2</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; A.diagonal_solve(B) == B/2</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonal</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix should be diagonal&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Size mis-match&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.dot"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dot product of Matrix self and b relaxing the condition</span>
<span class="sd">        of compatible dimensions: if either the number of rows or columns are</span>
<span class="sd">        the same as the length of b then the dot product is returned. If self</span>
<span class="sd">        is a row or column vector, a scalar is returned. Otherwise, a list</span>
<span class="sd">        of results is returned (and in that case the number of columns in self</span>
<span class="sd">        must match the length of b).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; v = [1, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; M.row(0).dot(v)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; M.col(0).dot(v)</span>
<span class="sd">        12</span>
<span class="sd">        &gt;&gt;&gt; M.dot(v)</span>
<span class="sd">        [6, 15, 24]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cross</span>
<span class="sd">        multiply</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="k">import</span> <span class="n">Matrix</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span>
                        <span class="s2">&quot;Dimensions incorrect for dot product: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">((</span><span class="n">mat</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">prod</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Dimensions incorrect for dot product: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.dual"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.dual">[docs]</a>    <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the dual of a matrix, which is:</span>

<span class="sd">        `(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices `k` and `l`</span>

<span class="sd">        Since the levicivita method is anti_symmetric for any pairwise</span>
<span class="sd">        exchange of indices, the dual of a symmetric matrix is the zero</span>
<span class="sd">        matrix. Strictly speaking the dual defined here assumes that the</span>
<span class="sd">        &#39;matrix&#39; `M` is a contravariant anti_symmetric second rank tensor,</span>
<span class="sd">        so that the dual is a covariant second rank tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">LeviCivita</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">zeros</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">work</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">acum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">acum</span> <span class="o">+=</span> <span class="n">LeviCivita</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">work</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">acum</span>
                <span class="n">work</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">acum</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">acum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">acum</span> <span class="o">+=</span> <span class="n">LeviCivita</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">acum</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">acum</span>
            <span class="n">work</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">acum</span>

        <span class="k">return</span> <span class="n">work</span></div>

<div class="viewcode-block" id="MatrixBase.exp"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the exponentiation of a square matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span>
                <span class="s2">&quot;Exponentiation is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">P</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_form</span><span class="p">()</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">get_diag_blocks</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">MatrixError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Exponentiation is implemented only for matrices for which the Jordan normal form can be computed&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_jblock_exponential</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="c1"># This function computes the matrix exponential for one single Jordan block</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">eye</span>
                <span class="c1"># extract the diagonal part</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">eye</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
                <span class="c1"># and the nilpotent part</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">d</span>
                <span class="c1"># compute its exponential</span>
                <span class="n">nex</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">):</span>
                    <span class="n">nex</span> <span class="o">=</span> <span class="n">nex</span> <span class="o">+</span> <span class="n">n</span> <span class="o">**</span> <span class="n">i</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># combine the two parts</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">nex</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_jblock_exponential</span><span class="p">,</span> <span class="n">cells</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">diag</span>
        <span class="n">eJ</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">)</span>
        <span class="c1"># n = self.rows</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">eJ</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.gauss_jordan_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.gauss_jordan_solve">[docs]</a>    <span class="k">def</span> <span class="nf">gauss_jordan_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">freevar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = b using Gauss Jordan elimination.</span>

<span class="sd">        There may be zero, one, or infinite solutions.  If one solution</span>
<span class="sd">        exists, it will be returned. If infinite solutions exist, it will</span>
<span class="sd">        be returned parametrically. If no solutions exist, It will throw</span>
<span class="sd">        ValueError.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        b : Matrix</span>
<span class="sd">            The right hand side of the equation to be solved for.  Must have</span>
<span class="sd">            the same number of rows as matrix A.</span>

<span class="sd">        freevar : List</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            values of free variables. Then the index of the free variables</span>
<span class="sd">            in the solutions (column Matrix) will be returned by freevar, if</span>
<span class="sd">            the flag `freevar` is set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        x : Matrix</span>
<span class="sd">            The matrix that will satisfy Ax = B.  Will have as many rows as</span>
<span class="sd">            matrix A has columns, and as many columns as matrix B.</span>

<span class="sd">        params : Matrix</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            parameters. These arbitrary parameters are returned as params</span>
<span class="sd">            Matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])</span>
<span class="sd">        &gt;&gt;&gt; b = Matrix([7, 12, 4])</span>
<span class="sd">        &gt;&gt;&gt; sol, params = A.gauss_jordan_solve(b)</span>
<span class="sd">        &gt;&gt;&gt; sol</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-2*_tau0 - 3*_tau1 + 2],</span>
<span class="sd">        [                 _tau0],</span>
<span class="sd">        [           2*_tau1 + 5],</span>
<span class="sd">        [                 _tau1]])</span>
<span class="sd">        &gt;&gt;&gt; params</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [_tau0],</span>
<span class="sd">        [_tau1]])</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])</span>
<span class="sd">        &gt;&gt;&gt; b = Matrix([3, 6, 9])</span>
<span class="sd">        &gt;&gt;&gt; sol, params = A.gauss_jordan_solve(b)</span>
<span class="sd">        &gt;&gt;&gt; sol</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 2],</span>
<span class="sd">        [ 0]])</span>
<span class="sd">        &gt;&gt;&gt; params</span>
<span class="sd">        Matrix(0, 1, [])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://en.wikipedia.org/wiki/Gaussian_elimination</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">zeros</span>

        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">aug</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># solve by reduced row echelon form</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pivots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">,</span> <span class="n">pivots</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span>

        <span class="c1"># Bring to block form</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">permutation</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pivots</span><span class="p">):</span>
            <span class="n">A</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># check for existence of solutions</span>
        <span class="c1"># rank of aug Matrix should be equal to rank of coefficient matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">[</span><span class="n">rank</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linear system has no solution&quot;</span><span class="p">)</span>

        <span class="c1"># Get index of free symbols (free parameters)</span>
        <span class="n">free_var_index</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">[</span>
                         <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">):]</span>  <span class="c1"># non-pivots columns are free variables</span>

        <span class="c1"># Free parameters</span>
        <span class="n">dummygen</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">dummygen</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">rank</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">col</span> <span class="o">-</span> <span class="n">rank</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Full parametric solution</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">rank</span><span class="p">,</span> <span class="n">rank</span><span class="p">:]</span>
        <span class="n">vt</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">rank</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">free_sol</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">vt</span> <span class="o">-</span> <span class="n">V</span> <span class="o">*</span> <span class="n">tau</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>

        <span class="c1"># Undo permutation</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">free_sol</span><span class="p">):</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">permutation</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">freevar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">free_var_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">tau</span></div>

<div class="viewcode-block" id="MatrixBase.inv_mod"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inv_mod">[docs]</a>    <span class="k">def</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the inverse of the matrix `K` (mod `m`), if it exists.</span>

<span class="sd">        Method to find the matrix inverse of `K` (mod `m`) implemented in this function:</span>

<span class="sd">        * Compute `\mathrm{adj}(K) = \mathrm{cof}(K)^t`, the adjoint matrix of `K`.</span>

<span class="sd">        * Compute `r = 1/\mathrm{det}(K) \pmod m`.</span>

<span class="sd">        * `K^{-1} = r\cdot \mathrm{adj}(K) \pmod m`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(2, 2, [1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A.inv_mod(5)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [3, 1],</span>
<span class="sd">        [4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; A.inv_mod(3)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 1],</span>
<span class="sd">        [0, 1]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="k">import</span> <span class="n">totient</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">totient</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">det_K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">det_K</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Matrix is not invertible (mod </span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">det_inv</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">det_K</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="n">K_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjugate</span><span class="p">()</span>
        <span class="n">K_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
                               <span class="p">[</span><span class="n">det_inv</span> <span class="o">*</span> <span class="n">K_adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="n">m</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span>
                                <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">K_inv</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_ADJ"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inverse_ADJ">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_ADJ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using the adjugate matrix and a determinant.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_LU</span>
<span class="sd">        inverse_GE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be square to invert.&quot;</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;berkowitz&#39;</span><span class="p">)</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zero</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if equals() can&#39;t decide, will rref be able to?</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">ok</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ok</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjugate</span><span class="p">()</span> <span class="o">/</span> <span class="n">d</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_GE"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inverse_GE">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_GE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using Gaussian elimination.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_LU</span>
<span class="sd">        inverse_ADJ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="k">import</span> <span class="n">Matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be square to invert.&quot;</span><span class="p">)</span>

        <span class="n">big</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(),</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="n">red</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">red</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">red</span><span class="p">[:,</span> <span class="n">big</span><span class="o">.</span><span class="n">rows</span><span class="p">:])</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_LU"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inverse_LU">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_LU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using LU decomposition.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_GE</span>
<span class="sd">        inverse_ADJ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">ok</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ok</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.inv"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse of a matrix.</span>

<span class="sd">        CASE 1: If the matrix is a dense matrix.</span>

<span class="sd">        Return the matrix inverse using the method indicated (default</span>
<span class="sd">        is Gauss elimination).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        method : (&#39;GE&#39;, &#39;LU&#39;, or &#39;ADJ&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        According to the ``method`` keyword, it calls the appropriate method:</span>

<span class="sd">          GE .... inverse_GE(); default</span>
<span class="sd">          LU .... inverse_LU()</span>
<span class="sd">          ADJ ... inverse_ADJ()</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inverse_LU</span>
<span class="sd">        inverse_GE</span>
<span class="sd">        inverse_ADJ</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the determinant of the matrix is zero.</span>

<span class="sd">        CASE 2: If the matrix is a sparse matrix.</span>

<span class="sd">        Return the matrix inverse using Cholesky or LDL (default).</span>

<span class="sd">        kwargs</span>
<span class="sd">        ======</span>

<span class="sd">        method : (&#39;CH&#39;, &#39;LDL&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        According to the ``method`` keyword, it calls the appropriate method:</span>

<span class="sd">          LDL ... inverse_LDL(); default</span>
<span class="sd">          CH .... inverse_CH()</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the determinant of the matrix is zero.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_inverse</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.is_nilpotent"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.is_nilpotent">[docs]</a>    <span class="k">def</span> <span class="nf">is_nilpotent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a matrix is nilpotent.</span>

<span class="sd">        A matrix B is nilpotent if for some integer k, B**k is</span>
<span class="sd">        a zero matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span>
                <span class="s2">&quot;Nilpotency is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="MatrixBase.key2bounds"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.key2bounds">[docs]</a>    <span class="k">def</span> <span class="nf">key2bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a key with potentially mixed types of keys (integer and slice)</span>
<span class="sd">        into a tuple of ranges and raises an error if any index is out of self&#39;s</span>
<span class="sd">        range.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        key2ij</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">islice</span><span class="p">,</span> <span class="n">jslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">islice</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="n">rlo</span> <span class="o">=</span> <span class="n">rhi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rlo</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">rhi</span> <span class="o">=</span> <span class="n">rlo</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">jslice</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="n">clo</span> <span class="o">=</span> <span class="n">chi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clo</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">clo</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span></div>

<div class="viewcode-block" id="MatrixBase.key2ij"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.key2ij">[docs]</a>    <span class="k">def</span> <span class="nf">key2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts key into canonical form, converting integers or indexable</span>
<span class="sd">        items into valid integers for self&#39;s range or returning slices</span>
<span class="sd">        unchanged.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        key2bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;key must be a sequence of length 2&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">a2idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">i</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a2idx</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.LDLdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LDLdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LDLdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the LDL Decomposition (L, D) of matrix A,</span>
<span class="sd">        such that L * D * L.T == A</span>
<span class="sd">        This method eliminates the use of square root.</span>
<span class="sd">        Further this ensures that all the diagonal entries of L are 1.</span>
<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))</span>
<span class="sd">        &gt;&gt;&gt; L, D = A.LDLdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [   1,   0, 0],</span>
<span class="sd">        [ 3/5,   1, 0],</span>
<span class="sd">        [-1/5, 1/3, 1]])</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [25, 0, 0],</span>
<span class="sd">        [ 0, 9, 0],</span>
<span class="sd">        [ 0, 0, 9]])</span>
<span class="sd">        &gt;&gt;&gt; L * D * L.T * A.inv() == eye(A.rows)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LDLdecomposition</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.LDLsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LDLsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LDLsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B using LDL decomposition,</span>
<span class="sd">        for a general square and non-singular matrix.</span>

<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = eye(2)*2</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; A.LDLsolve(B) == B/2</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LDLdecomposition</span>
<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Under-determined System. &#39;</span>
                                      <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.lower_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.lower_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">lower_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B, where A is a lower triangular matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrices size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lower</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be lower triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.LUdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LUdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span>
                        <span class="n">simpfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">rankcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (L, U, perm) where L is a lower triangular matrix with unit</span>
<span class="sd">        diagonal, U is an upper triangular matrix, and perm is a list of row</span>
<span class="sd">        swap index pairs. If A is the original matrix, then</span>
<span class="sd">        A = (L*U).permuteBkwd(perm), and the row permutation matrix P such</span>
<span class="sd">        that P*A = L*U can be computed by P=eye(A.row).permuteFwd(perm).</span>

<span class="sd">        See documentation for LUCombined for details about the keyword argument</span>
<span class="sd">        rankcheck, iszerofunc, and simpfunc.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[4, 3], [6, 3]])</span>
<span class="sd">        &gt;&gt;&gt; L, U, _ = a.LUdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [  1, 0],</span>
<span class="sd">        [3/2, 1]])</span>
<span class="sd">        &gt;&gt;&gt; U</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [4,    3],</span>
<span class="sd">        [0, -3/2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LDLdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        LUdecomposition_Simple</span>
<span class="sd">        LUdecompositionFF</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">combined</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span>
                                                  <span class="n">simpfunc</span><span class="o">=</span><span class="n">simpfunc</span><span class="p">,</span>
                                                  <span class="n">rankcheck</span><span class="o">=</span><span class="n">rankcheck</span><span class="p">)</span>

        <span class="c1"># L is lower triangular self.rows x self.rows</span>
        <span class="c1"># U is upper triangular self.rows x self.cols</span>
        <span class="c1"># L has unit diagonal. For each column in combined, the subcolumn</span>
        <span class="c1"># below the diagonal of combined is shared by L.</span>
        <span class="c1"># If L has more columns than combined, then the remaining subcolumns</span>
        <span class="c1"># below the diagonal of L are zero.</span>
        <span class="c1"># The upper triangular portion of L and combined are equal.</span>
        <span class="k">def</span> <span class="nf">entry_L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="c1"># Super diagonal entry</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">combined</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="c1"># Subdiagonal entry of L with no corresponding</span>
            <span class="c1"># entry in combined</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">def</span> <span class="nf">entry_U</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span> <span class="k">else</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">combined</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">entry_L</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">combined</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">entry_U</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span></div>


<div class="viewcode-block" id="MatrixBase.LUdecomposition_Simple"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LUdecomposition_Simple">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition_Simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span>
                               <span class="n">simpfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">rankcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute an lu decomposition of m x n matrix A, where P*A = L*U</span>

<span class="sd">        * L is m x m lower triangular with unit diagonal</span>
<span class="sd">        * U is m x n upper triangular</span>
<span class="sd">        * P is an m x m permutation matrix</span>

<span class="sd">        Returns an m x n matrix lu, and an m element list perm where each</span>
<span class="sd">        element of perm is a pair of row exchange indices.</span>

<span class="sd">        The factors L and U are stored in lu as follows:</span>
<span class="sd">        The subdiagonal elements of L are stored in the subdiagonal elements</span>
<span class="sd">        of lu, that is lu[i, j] = L[i, j] whenever i &gt; j.</span>
<span class="sd">        The elements on the diagonal of L are all 1, and are not explicitly</span>
<span class="sd">        stored.</span>
<span class="sd">        U is stored in the upper triangular portion of lu, that is</span>
<span class="sd">        lu[i ,j] = U[i, j] whenever i &lt;= j.</span>
<span class="sd">        The output matrix can be visualized as:</span>

<span class="sd">        Matrix([</span>
<span class="sd">            [u, u, u, u],</span>
<span class="sd">            [l, u, u, u],</span>
<span class="sd">            [l, l, u, u],</span>
<span class="sd">            [l, l, l, u]])</span>

<span class="sd">        where l represents a subdiagonal entry of the L factor, and u</span>
<span class="sd">        represents an entry from the upper triangular entry of the U</span>
<span class="sd">        factor.</span>

<span class="sd">        perm is a list row swap index pairs such that if A is the original</span>
<span class="sd">        matrix, then A = (L*U).permuteBkwd(perm), and the row permutation</span>
<span class="sd">        matrix P such that P*A = L*U can be computed by</span>
<span class="sd">        soP=eye(A.row).permuteFwd(perm).</span>

<span class="sd">        The keyword argument rankcheck determines if this function raises a</span>
<span class="sd">        ValueError when passed a matrix whose rank is strictly less than</span>
<span class="sd">        min(num rows, num cols). The default behavior is to decompose a rank</span>
<span class="sd">        deficient matrix. Pass rankcheck=True to raise a</span>
<span class="sd">        ValueError instead. (This mimics the previous behavior of this function).</span>

<span class="sd">        The keyword arguments iszerofunc and simpfunc are used by the pivot</span>
<span class="sd">        search algorithm.</span>
<span class="sd">        iszerofunc is a callable that returns a boolean indicating if its</span>
<span class="sd">        input is zero, or None if it cannot make the determination.</span>
<span class="sd">        simpfunc is a callable that simplifies its input.</span>
<span class="sd">        The default is simpfunc=None, which indicate that the pivot search</span>
<span class="sd">        algorithm should not attempt to simplify any candidate pivots.</span>
<span class="sd">        If simpfunc fails to simplify its input, then it must return its input</span>
<span class="sd">        instead of a copy.</span>

<span class="sd">        When a matrix contains symbolic entries, the pivot search algorithm</span>
<span class="sd">        differs from the case where every entry can be categorized as zero or</span>
<span class="sd">        nonzero.</span>
<span class="sd">        The algorithm searches column by column through the submatrix whose</span>
<span class="sd">        top left entry coincides with the pivot position.</span>
<span class="sd">        If it exists, the pivot is the first entry in the current search</span>
<span class="sd">        column that iszerofunc guarantees is nonzero.</span>
<span class="sd">        If no such candidate exists, then each candidate pivot is simplified</span>
<span class="sd">        if simpfunc is not None.</span>
<span class="sd">        The search is repeated, with the difference that a candidate may be</span>
<span class="sd">        the pivot if `iszerofunc()` cannot guarantee that it is nonzero.</span>
<span class="sd">        In the second search the pivot is the first candidate that</span>
<span class="sd">        iszerofunc can guarantee is nonzero.</span>
<span class="sd">        If no such candidate exists, then the pivot is the first candidate</span>
<span class="sd">        for which iszerofunc returns None.</span>
<span class="sd">        If no such candidate exists, then the search is repeated in the next</span>
<span class="sd">        column to the right.</span>
<span class="sd">        The pivot search algorithm differs from the one in `rref()`, which</span>
<span class="sd">        relies on `_find_reasonable_pivot()`.</span>
<span class="sd">        Future versions of `LUdecomposition_simple()` may use</span>
<span class="sd">        `_find_reasonable_pivot()`.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LUdecomposition</span>
<span class="sd">        LUdecompositionFF</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rankcheck</span><span class="p">:</span>
            <span class="c1"># https://github.com/sympy/sympy/issues/9796</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Define LU decomposition of a matrix with no entries as a matrix</span>
            <span class="c1"># of the same dimensions with all zero entries.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">),</span> <span class="p">[]</span>

        <span class="n">lu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="n">row_swaps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">pivot_col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pivot_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Search for pivot. Prefer entry that iszeropivot determines</span>
            <span class="c1"># is nonzero, over entry that iszeropivot cannot guarantee</span>
            <span class="c1"># is  zero.</span>
            <span class="c1"># XXX `_find_reasonable_pivot` uses slow zero testing. Blocked by bug #10279</span>
            <span class="c1"># Future versions of LUdecomposition_simple can pass iszerofunc and simpfunc</span>
            <span class="c1"># to _find_reasonable_pivot().</span>
            <span class="c1"># In pass 3 of _find_reasonable_pivot(), the predicate in `if x.equals(S.Zero):`</span>
            <span class="c1"># calls sympy.simplify(), and not the simplification function passed in via</span>
            <span class="c1"># the keyword argument simpfunc.</span>

            <span class="n">iszeropivot</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">pivot_col</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">and</span> <span class="n">iszeropivot</span><span class="p">:</span>
                <span class="n">sub_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">lu</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pivot_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
                <span class="n">pivot_row_offset</span><span class="p">,</span> <span class="n">pivot_value</span><span class="p">,</span> <span class="n">is_assumed_non_zero</span><span class="p">,</span> <span class="n">ind_simplified_pairs</span> <span class="o">=</span>\
                    <span class="n">_find_reasonable_pivot_naive</span><span class="p">(</span><span class="n">sub_col</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simpfunc</span><span class="p">)</span>
                <span class="n">iszeropivot</span> <span class="o">=</span> <span class="n">pivot_value</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">iszeropivot</span><span class="p">:</span>
                    <span class="c1"># All candidate pivots in this column are zero.</span>
                    <span class="c1"># Proceed to next column.</span>
                    <span class="n">pivot_col</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">rankcheck</span> <span class="ow">and</span> <span class="n">pivot_col</span> <span class="o">!=</span> <span class="n">pivot_row</span><span class="p">:</span>
                <span class="c1"># All entries including and below the pivot position are</span>
                <span class="c1"># zero, which indicates that the rank of the matrix is</span>
                <span class="c1"># strictly less than min(num rows, num cols)</span>
                <span class="c1"># Mimic behavior of previous implementation, by throwing a</span>
                <span class="c1"># ValueError.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rank of matrix is strictly less than&quot;</span>
                                 <span class="s2">&quot; number of rows or columns.&quot;</span>
                                 <span class="s2">&quot; Pass keyword argument&quot;</span>
                                 <span class="s2">&quot; rankcheck=False to compute&quot;</span>
                                 <span class="s2">&quot; the LU decomposition of this matrix.&quot;</span><span class="p">)</span>

            <span class="n">candidate_pivot_row</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">pivot_row_offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pivot_row</span> <span class="o">+</span> <span class="n">pivot_row_offset</span>

            <span class="k">if</span> <span class="n">candidate_pivot_row</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">iszeropivot</span><span class="p">:</span>
                <span class="c1"># If candidate_pivot_row is None and iszeropivot is True</span>
                <span class="c1"># after pivot search has completed, then the submatrix</span>
                <span class="c1"># below and to the right of (pivot_row, pivot_col) is</span>
                <span class="c1"># all zeros, indicating that Gaussian elimination is</span>
                <span class="c1"># complete.</span>
                <span class="k">return</span> <span class="n">lu</span><span class="p">,</span> <span class="n">row_swaps</span>

            <span class="c1"># Update entries simplified during pivot search.</span>
            <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ind_simplified_pairs</span><span class="p">:</span>
                <span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">if</span> <span class="n">pivot_row</span> <span class="o">!=</span> <span class="n">candidate_pivot_row</span><span class="p">:</span>
                <span class="c1"># Row swap book keeping:</span>
                <span class="c1"># Record which rows were swapped.</span>
                <span class="c1"># Update stored portion of L factor by multiplying L on the</span>
                <span class="c1"># left and right with the current permutation.</span>
                <span class="c1"># Swap rows of U.</span>
                <span class="n">row_swaps</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pivot_row</span><span class="p">,</span> <span class="n">candidate_pivot_row</span><span class="p">])</span>

                <span class="c1"># Update L.</span>
                <span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pivot_row</span><span class="p">],</span> <span class="n">lu</span><span class="p">[</span><span class="n">candidate_pivot_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pivot_row</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">lu</span><span class="p">[</span><span class="n">candidate_pivot_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pivot_row</span><span class="p">],</span> <span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pivot_row</span><span class="p">]</span>

                <span class="c1"># Swap pivot row of U with candidate pivot row.</span>
                <span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">:</span><span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">],</span> <span class="n">lu</span><span class="p">[</span><span class="n">candidate_pivot_row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">:</span><span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">lu</span><span class="p">[</span><span class="n">candidate_pivot_row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">:</span><span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">],</span> <span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">:</span><span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>

            <span class="c1"># Introduce zeros below the pivot by adding a multiple of the</span>
            <span class="c1"># pivot row to a row under it, and store the result in the</span>
            <span class="c1"># row under it.</span>
            <span class="c1"># Only entries in the target row whose index is greater than</span>
            <span class="c1"># start_col may be nonzero.</span>
            <span class="n">start_col</span> <span class="o">=</span> <span class="n">pivot_col</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pivot_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="c1"># Store factors of L in the subcolumn below</span>
                <span class="c1"># (pivot_row, pivot_row).</span>
                <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">pivot_row</span><span class="p">]</span> <span class="o">=</span>\
                    <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">]</span><span class="o">/</span><span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">]</span>

                <span class="c1"># Form the linear combination of the pivot row and the current</span>
                <span class="c1"># row below the pivot row that zeros the entries below the pivot.</span>
                <span class="c1"># Employing slicing instead of a loop here raises</span>
                <span class="c1"># NotImplementedError: Cannot add Zero to MutableSparseMatrix</span>
                <span class="c1"># in sympy/matrices/tests/test_sparse.py.</span>
                <span class="c1"># c = pivot_row + 1 if pivot_row == pivot_col else pivot_col</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_col</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">pivot_row</span><span class="p">]</span><span class="o">*</span><span class="n">lu</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">pivot_row</span> <span class="o">!=</span> <span class="n">pivot_col</span><span class="p">:</span>
                <span class="c1"># matrix rank &lt; min(num rows, num cols),</span>
                <span class="c1"># so factors of L are not stored directly below the pivot.</span>
                <span class="c1"># These entries are zero by construction, so don&#39;t bother</span>
                <span class="c1"># computing them.</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pivot_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">lu</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">pivot_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="n">pivot_col</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pivot_col</span> <span class="o">==</span> <span class="n">lu</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="c1"># All candidate pivots are zero implies that Gaussian</span>
                <span class="c1"># elimination is complete.</span>
                <span class="k">return</span> <span class="n">lu</span><span class="p">,</span> <span class="n">row_swaps</span>

        <span class="k">return</span> <span class="n">lu</span><span class="p">,</span> <span class="n">row_swaps</span></div>

<div class="viewcode-block" id="MatrixBase.LUdecompositionFF"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LUdecompositionFF">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecompositionFF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a fraction-free LU decomposition.</span>

<span class="sd">        Returns 4 matrices P, L, D, U such that PA = L D**-1 U.</span>
<span class="sd">        If the elements of the matrix belong to some integral domain I, then all</span>
<span class="sd">        elements of L, D and U are guaranteed to belong to I.</span>

<span class="sd">        **Reference**</span>
<span class="sd">            - W. Zhou &amp; D.J. Jeffrey, &quot;Fraction-free matrix factors: new forms</span>
<span class="sd">              for LU and QR factors&quot;. Frontiers in Computer Science in China,</span>
<span class="sd">              Vol 2, no. 1, pp. 67-80, 2008.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LUdecomposition</span>
<span class="sd">        LUdecomposition_Simple</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">SparseMatrix</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">zeros</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">eye</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(),</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">oldpivot</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kpivot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix is not full rank&quot;</span><span class="p">)</span>
                <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ukk</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">DD</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span> <span class="o">*</span> <span class="n">Ukk</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Uik</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ukk</span> <span class="o">*</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Uik</span><span class="p">)</span> <span class="o">/</span> <span class="n">oldpivot</span>
                <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">oldpivot</span> <span class="o">=</span> <span class="n">Ukk</span>
        <span class="n">DD</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">DD</span><span class="p">,</span> <span class="n">U</span></div>

<div class="viewcode-block" id="MatrixBase.LUsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LUsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the linear system Ax = rhs for x where A = self.</span>

<span class="sd">        This is for symbolic matrices, for real or complex ones use</span>
<span class="sd">        mpmath.lu_solve or mpmath.qr_solve.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span>
                <span class="s2">&quot;`self` and `rhs` must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="c1"># forward substitution, all diag entries are scaled to 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">b</span><span class="o">.</span><span class="n">zip_row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
        <span class="c1"># backward substitution</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">b</span><span class="o">.</span><span class="n">zip_row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">b</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rhs</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.multiply"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self*b</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        dot</span>
<span class="sd">        cross</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">b</span></div>

<div class="viewcode-block" id="MatrixBase.normalized"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.normalized">[docs]</a>    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the normalized version of ``self``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        norm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be a vector to normalize.&quot;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MatrixBase.norm"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Norm of a Matrix or Vector.</span>
<span class="sd">        In the simplest case this is the geometric size of the vector</span>
<span class="sd">        Other norms can be specified by the ord parameter</span>


<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        ord    norm for matrices             norm for vectors</span>
<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        None   Frobenius norm                2-norm</span>
<span class="sd">        &#39;fro&#39;  Frobenius norm                - does not exist</span>
<span class="sd">        inf    --                            max(abs(x))</span>
<span class="sd">        -inf   --                            min(abs(x))</span>
<span class="sd">        1      --                            as below</span>
<span class="sd">        -1     --                            as below</span>
<span class="sd">        2      2-norm (largest sing. value)  as below</span>
<span class="sd">        -2     smallest singular value       as below</span>
<span class="sd">        other  - does not exist              sum(abs(x)**ord)**(1./ord)</span>
<span class="sd">        =====  ============================  ==========================</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Symbol, trigsimp, cos, sin, oo</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; v = Matrix([cos(x), sin(x)])</span>
<span class="sd">        &gt;&gt;&gt; trigsimp( v.norm() )</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; v.norm(10)</span>
<span class="sd">        (sin(x)**10 + cos(x)**10)**(1/10)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 1], [1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; A.norm(2)# Spectral norm (max of |Ax|/|x| under 2-vector-norm)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; A.norm(-2) # Inverse spectral norm (smallest singular value)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; A.norm() # Frobenius Norm</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Matrix([1, -2]).norm(oo)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Matrix([-1, 2]).norm(-oo)</span>
<span class="sd">        1</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        normalized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Row or Column Vector Norms</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">ord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Common case sqrt(&lt;x, x&gt;)</span>
                <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sum(abs(x))</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>  <span class="c1"># max(abs(x))</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>  <span class="c1"># min(abs(x))</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span>

            <span class="c1"># Otherwise generalize the 2-norm, Sum(x_i**ord)**(1/ord)</span>
            <span class="c1"># Note that while useful this is not mathematically a norm</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">**</span> <span class="nb">ord</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">)),</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">ord</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected order to be Number, Symbol, oo&quot;</span><span class="p">)</span>

        <span class="c1"># Matrix Norms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Spectral Norm</span>
                <span class="c1"># Maximum singular value</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Minimum singular value</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">ord</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span>
                                            <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span>
                <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">,</span> <span class="s1">&#39;frobenius&#39;</span><span class="p">,</span> <span class="s1">&#39;vector&#39;</span><span class="p">]):</span>
                <span class="c1"># Reshape as vector and send back to norm function</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Matrix Norms under development&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.pinv_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.pinv_solve">[docs]</a>    <span class="k">def</span> <span class="nf">pinv_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">arbitrary_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve Ax = B using the Moore-Penrose pseudoinverse.</span>

<span class="sd">        There may be zero, one, or infinite solutions.  If one solution</span>
<span class="sd">        exists, it will be returned.  If infinite solutions exist, one will</span>
<span class="sd">        be returned based on the value of arbitrary_matrix.  If no solutions</span>
<span class="sd">        exist, the least-squares solution is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        B : Matrix</span>
<span class="sd">            The right hand side of the equation to be solved for.  Must have</span>
<span class="sd">            the same number of rows as matrix A.</span>
<span class="sd">        arbitrary_matrix : Matrix</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            matrix.  This parameter may be set to a specific matrix to use</span>
<span class="sd">            for that purpose; if so, it must be the same shape as x, with as</span>
<span class="sd">            many rows as matrix A has columns, and as many columns as matrix</span>
<span class="sd">            B.  If left as None, an appropriate matrix containing dummy</span>
<span class="sd">            symbols in the form of ``wn_m`` will be used, with n and m being</span>
<span class="sd">            row and column position of each symbol.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        x : Matrix</span>
<span class="sd">            The matrix that will satisfy Ax = B.  Will have as many rows as</span>
<span class="sd">            matrix A has columns, and as many columns as matrix B.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([7, 8])</span>
<span class="sd">        &gt;&gt;&gt; A.pinv_solve(B)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],</span>
<span class="sd">        [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],</span>
<span class="sd">        [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])</span>
<span class="sd">        &gt;&gt;&gt; A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-55/18],</span>
<span class="sd">        [   1/9],</span>
<span class="sd">        [ 59/18]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This may return either exact solutions or least squares solutions.</span>
<span class="sd">        To determine which, check ``A * A.pinv() * B == B``.  It will be</span>
<span class="sd">        True if exact solutions exist, and False if only a least-squares</span>
<span class="sd">        solution exists.  Be aware that the left hand side of that equation</span>
<span class="sd">        may need to be simplified to correctly compare to the right hand</span>
<span class="sd">        side.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">eye</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">A_pinv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">arbitrary_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w:</span><span class="si">{0}</span><span class="s1">_:</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">),</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
            <span class="n">arbitrary_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">A_pinv</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="o">-</span> <span class="n">A_pinv</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">arbitrary_matrix</span></div>

<div class="viewcode-block" id="MatrixBase.pinv"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.pinv">[docs]</a>    <span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the Moore-Penrose pseudoinverse of the matrix.</span>

<span class="sd">        The Moore-Penrose pseudoinverse exists and is unique for any matrix.</span>
<span class="sd">        If the matrix is invertible, the pseudoinverse is the same as the</span>
<span class="sd">        inverse.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; Matrix([[1, 2, 3], [4, 5, 6]]).pinv()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-17/18,  4/9],</span>
<span class="sd">        [  -1/9,  1/9],</span>
<span class="sd">        [ 13/18, -2/9]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        pinv_solve</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">AH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>
        <span class="c1"># Trivial case: pseudoinverse of all-zero matrix is its transpose.</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AH</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">AH</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">AH</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AH</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">AH</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Matrix is not full rank, so A*AH cannot be inverted.</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Rank-deficient matrices are not yet &#39;</span>
                                      <span class="s1">&#39;supported.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.print_nonzero"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.print_nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">print_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symb</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shows location of non-zero entries for fast shape lookup.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 3, lambda i, j: i*3+j)</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1, 2],</span>
<span class="sd">        [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; m.print_nonzero()</span>
<span class="sd">        [ XX]</span>
<span class="sd">        [XXX]</span>
<span class="sd">        &gt;&gt;&gt; m = eye(4)</span>
<span class="sd">        &gt;&gt;&gt; m.print_nonzero(&quot;x&quot;)</span>
<span class="sd">        [x   ]</span>
<span class="sd">        [ x  ]</span>
<span class="sd">        [  x ]</span>
<span class="sd">        [   x]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">symb</span><span class="p">))</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.project"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the projection of ``self`` onto the line containing ``v``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, S, sqrt</span>
<span class="sd">        &gt;&gt;&gt; V = Matrix([sqrt(3)/2, S.Half])</span>
<span class="sd">        &gt;&gt;&gt; x = Matrix([[1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; V.project(x)</span>
<span class="sd">        Matrix([[sqrt(3)/2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; V.project(-x)</span>
<span class="sd">        Matrix([[sqrt(3)/2, 0]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.QRdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.QRdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">QRdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Q, R where A = Q*R, Q is orthogonal and R is upper triangular.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        This is the example from wikipedia:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 6/7, -69/175, -58/175],</span>
<span class="sd">        [ 3/7, 158/175,   6/175],</span>
<span class="sd">        [-2/7,    6/35,  -33/35]])</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [14,  21, -14],</span>
<span class="sd">        [ 0, 175, -70],</span>
<span class="sd">        [ 0,   0,  35]])</span>
<span class="sd">        &gt;&gt;&gt; A == Q*R</span>
<span class="sd">        True</span>

<span class="sd">        QR factorization of an identity matrix:</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 0, 1]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LDLdecomposition</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span>
                <span class="s2">&quot;The number of rows must be greater than columns&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">row_reduced</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rref</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_reduced</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row_reduced</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;The rank of the matrix must match the columns&quot;</span><span class="p">)</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>  <span class="c1"># for each column vector</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># take original v</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="c1"># subtract the project of mat on new vector</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="c1"># normalize it</span>
            <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
            <span class="n">Q</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not normalize the vector </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="bp">cls</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.QRsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.QRsolve">[docs]</a>    <span class="k">def</span> <span class="nf">QRsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the linear system &#39;Ax = b&#39;.</span>

<span class="sd">        &#39;self&#39; is the matrix &#39;A&#39;, the method argument is the vector</span>
<span class="sd">        &#39;b&#39;.  The method returns the solution vector &#39;x&#39;.  If &#39;b&#39; is a</span>
<span class="sd">        matrix, the system is solved for each column of &#39;b&#39; and the</span>
<span class="sd">        return value is a matrix of the same shape as &#39;b&#39;.</span>

<span class="sd">        This method is slower (approximately by a factor of 2) but</span>
<span class="sd">        more stable for floating-point arithmetic than the LUsolve method.</span>
<span class="sd">        However, LUsolve usually uses an exact arithmetic, so you don&#39;t need</span>
<span class="sd">        to use QRsolve.</span>

<span class="sd">        This is mainly for educational purposes and symbolic matrices, for real</span>
<span class="sd">        (or complex) matrices use mpmath.qr_solve.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span><span class="o">.</span><span class="n">QRdecomposition</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">b</span>

        <span class="c1"># back substitution to solve R*x = y:</span>
        <span class="c1"># We build up the result &quot;backwards&quot; in the vector &#39;x&#39; and reverse it</span>
        <span class="c1"># only in the end.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">([</span><span class="n">row</span><span class="o">.</span><span class="n">_mat</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span></div>

<div class="viewcode-block" id="MatrixBase.solve_least_squares"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.solve_least_squares">[docs]</a>    <span class="k">def</span> <span class="nf">solve_least_squares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;CH&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the least-square fit to the data.</span>

<span class="sd">        By default the cholesky_solve routine is used (method=&#39;CH&#39;); other</span>
<span class="sd">        methods of matrix inversion can be used. To find out which are</span>
<span class="sd">        available, see the docstring of the .inv() method.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, ones</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; S = Matrix(A.row_join(B))</span>
<span class="sd">        &gt;&gt;&gt; S</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2],</span>
<span class="sd">        [2, 3],</span>
<span class="sd">        [3, 4]])</span>

<span class="sd">        If each line of S represent coefficients of Ax + By</span>
<span class="sd">        and x and y are [2, 3] then S*xy is:</span>

<span class="sd">        &gt;&gt;&gt; r = S*Matrix([2, 3]); r</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 8],</span>
<span class="sd">        [13],</span>
<span class="sd">        [18]])</span>

<span class="sd">        But let&#39;s add 1 to the middle value and then solve for the</span>
<span class="sd">        least-squares value of xy:</span>

<span class="sd">        &gt;&gt;&gt; xy = S.solve_least_squares(Matrix([8, 14, 18])); xy</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 5/3],</span>
<span class="sd">        [10/3]])</span>

<span class="sd">        The error is given by S*xy - r:</span>

<span class="sd">        &gt;&gt;&gt; S*xy - r</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [1/3]])</span>
<span class="sd">        &gt;&gt;&gt; _.norm().n(2)</span>
<span class="sd">        0.58</span>

<span class="sd">        If a different xy is used, the norm will be higher:</span>

<span class="sd">        &gt;&gt;&gt; xy += ones(2, 1)/10</span>
<span class="sd">        &gt;&gt;&gt; (S*xy - r).norm().n(2)</span>
<span class="sd">        1.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;CH&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">rhs</span></div>

<div class="viewcode-block" id="MatrixBase.solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;GE&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return solution to self*soln = rhs using given inversion method.</span>

<span class="sd">        For a list of possible inversion methods, see the .inv() docstring.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Under-determined system. &#39;</span>
                                 <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For over-determined system, M, having &#39;</span>
                                 <span class="s1">&#39;more rows than columns, try M.solve_least_squares(rhs).&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="o">*</span> <span class="n">rhs</span></div>

<div class="viewcode-block" id="MatrixBase.table"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.table">[docs]</a>    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">,</span> <span class="n">rowstart</span><span class="o">=</span><span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="n">rowend</span><span class="o">=</span><span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
              <span class="n">colsep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String form of Matrix as a table.</span>

<span class="sd">        ``printer`` is the printer to use for on the elements (generally</span>
<span class="sd">        something like StrPrinter())</span>

<span class="sd">        ``rowstart`` is the string used to start each row (by default &#39;[&#39;).</span>

<span class="sd">        ``rowend`` is the string used to end each row (by default &#39;]&#39;).</span>

<span class="sd">        ``rowsep`` is the string used to separate rows (by default a newline).</span>

<span class="sd">        ``colsep`` is the string used to separate columns (by default &#39;, &#39;).</span>

<span class="sd">        ``align`` defines how the elements are aligned. Must be one of &#39;left&#39;,</span>
<span class="sd">        &#39;right&#39;, or &#39;center&#39;.  You can also use &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;^&#39; to mean the</span>
<span class="sd">        same thing, respectively.</span>

<span class="sd">        This is used by the string printer for Matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.printing.str import StrPrinter</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[1, 2], [-33, 4]])</span>
<span class="sd">        &gt;&gt;&gt; printer = StrPrinter()</span>
<span class="sd">        &gt;&gt;&gt; M.table(printer)</span>
<span class="sd">        &#39;[  1, 2]\n[-33, 4]&#39;</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer))</span>
<span class="sd">        [  1, 2]</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, rowsep=&#39;,\n&#39;))</span>
<span class="sd">        [  1, 2],</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;[%s]&#39; % M.table(printer, rowsep=&#39;,\n&#39;))</span>
<span class="sd">        [[  1, 2],</span>
<span class="sd">        [-33, 4]]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, colsep=&#39; &#39;))</span>
<span class="sd">        [  1 2]</span>
<span class="sd">        [-33 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, align=&#39;center&#39;))</span>
<span class="sd">        [ 1 , 2]</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, rowstart=&#39;{&#39;, rowend=&#39;}&#39;))</span>
<span class="sd">        {  1, 2}</span>
<span class="sd">        {-33, 4}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle zero dimensions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;[]&#39;</span>
        <span class="c1"># Build table of string representations of the elements</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Track per-column max lengths for pretty alignment</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">printer</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c1"># Patch strings together</span>
        <span class="n">align</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;ljust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;rjust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="s1">&#39;ljust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="s1">&#39;rjust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;^&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">align</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">align</span><span class="p">)(</span><span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rowstart</span> <span class="o">+</span> <span class="n">colsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="n">rowend</span>
        <span class="k">return</span> <span class="n">rowsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.upper_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.upper_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">upper_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B, where A is an upper triangular matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_upper</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix is not upper triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.vech"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.MatrixBase.vech">[docs]</a>    <span class="k">def</span> <span class="nf">vech</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique elements of a symmetric Matrix as a one column matrix</span>
<span class="sd">        by stacking the elements in the lower triangle.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        diagonal -- include the diagonal cells of self or not</span>
<span class="sd">        check_symmetry -- checks symmetry of self but not completely reliably</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix([[1, 2], [2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2],</span>
<span class="sd">        [2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m.vech()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1],</span>
<span class="sd">        [2],</span>
<span class="sd">        [3]])</span>
<span class="sd">        &gt;&gt;&gt; m.vech(diagonal=False)</span>
<span class="sd">        Matrix([[2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        vec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">zeros</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_symmetry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Matrix appears to be asymmetric; consider check_symmetry=False&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">diagonal</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">v</span></div></div>


<div class="viewcode-block" id="classof"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.classof">[docs]</a><span class="k">def</span> <span class="nf">classof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the type of the result when combining matrices of different types.</span>

<span class="sd">    Currently the strategy is that immutability is contagious.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix, ImmutableMatrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.matrices.matrices import classof</span>
<span class="sd">    &gt;&gt;&gt; M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix</span>
<span class="sd">    &gt;&gt;&gt; IM = ImmutableMatrix([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; classof(M, IM)</span>
<span class="sd">    &lt;class &#39;sympy.matrices.immutable.ImmutableDenseMatrix&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">_class_priority</span> <span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">_class_priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numpy</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Incompatible classes </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>


<div class="viewcode-block" id="a2idx"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.matrices.a2idx">[docs]</a><span class="k">def</span> <span class="nf">a2idx</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return integer after making positive and validating against n.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Invalid index a[</span><span class="si">%r</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_find_reasonable_pivot</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simpfunc</span><span class="o">=</span><span class="n">_simplify</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the lowest index of an item in `col` that is</span>
<span class="sd">    suitable for a pivot.  If `col` consists only of</span>
<span class="sd">    Floats, the pivot with the largest norm is returned.</span>
<span class="sd">    Otherwise, the first element where `iszerofunc` returns</span>
<span class="sd">    False is used.  If `iszerofunc` doesn&#39;t return false,</span>
<span class="sd">    items are simplified and retested until a suitable</span>
<span class="sd">    pivot is found.</span>

<span class="sd">    Returns a 4-tuple</span>
<span class="sd">        (pivot_offset, pivot_val, assumed_nonzero, newly_determined)</span>
<span class="sd">    where pivot_offset is the index of the pivot, pivot_val is</span>
<span class="sd">    the (possibly simplified) value of the pivot, assumed_nonzero</span>
<span class="sd">    is True if an assumption that the pivot was non-zero</span>
<span class="sd">    was made without being proved, and newly_determined are</span>
<span class="sd">    elements that were simplified during the process of pivot</span>
<span class="sd">    finding.&quot;&quot;&quot;</span>

    <span class="n">newly_determined</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="c1"># a column that contains a mix of floats and integers</span>
    <span class="c1"># but at least one float is considered a numerical</span>
    <span class="c1"># column, and so we do partial pivoting</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Float</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">):</span>
        <span class="n">col_abs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">col_abs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">max_value</span><span class="p">):</span>
            <span class="c1"># just because iszerofunc returned True, doesn&#39;t</span>
            <span class="c1"># mean the value is numerically zero.  Make sure</span>
            <span class="c1"># to replace all entries with numerical zeros</span>
            <span class="k">if</span> <span class="n">max_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newly_determined</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">col_abs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>

    <span class="c1"># PASS 1 (iszerofunc directly)</span>
    <span class="n">possible_zeros</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="n">is_zero</span> <span class="o">=</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># is someone wrote a custom iszerofunc, it may return</span>
        <span class="c1"># BooleanFalse or BooleanTrue instead of True or False,</span>
        <span class="c1"># so use == for comparison instead of `is`</span>
        <span class="k">if</span> <span class="n">is_zero</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># we found something that is definitely not zero</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>
        <span class="n">possible_zeros</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_zero</span><span class="p">)</span>

    <span class="c1"># by this point, we&#39;ve found no certain non-zeros</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">possible_zeros</span><span class="p">):</span>
        <span class="c1"># if everything is definitely zero, we have</span>
        <span class="c1"># no pivot</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>

    <span class="c1"># PASS 2 (iszerofunc after simplify)</span>
    <span class="c1"># we haven&#39;t found any for-sure non-zeros, so</span>
    <span class="c1"># go through the elements iszerofunc couldn&#39;t</span>
    <span class="c1"># make a determination about and opportunistically</span>
    <span class="c1"># simplify to see if we find something</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">possible_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">simped</span> <span class="o">=</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">is_zero</span> <span class="o">=</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">simped</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_zero</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">is_zero</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">newly_determined</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">simped</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_zero</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">simped</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>
        <span class="n">possible_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_zero</span>

    <span class="c1"># after simplifying, some things that were recognized</span>
    <span class="c1"># as zeros might be zeros</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">possible_zeros</span><span class="p">):</span>
        <span class="c1"># if everything is definitely zero, we have</span>
        <span class="c1"># no pivot</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>

    <span class="c1"># PASS 3 (.equals(0))</span>
    <span class="c1"># some expressions fail to simplify to zero, but</span>
    <span class="c1"># `.equals(0)` evaluates to True.  As a last-ditch</span>
    <span class="c1"># attempt, apply `.equals` to these expressions</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">possible_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">):</span>
            <span class="c1"># `.iszero` may return False with</span>
            <span class="c1"># an implicit assumption (e.g., `x.equals(0)`</span>
            <span class="c1"># when `x` is a symbol), so only treat it</span>
            <span class="c1"># as proved when `.equals(0)` returns True</span>
            <span class="n">possible_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">newly_determined</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">possible_zeros</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>

    <span class="c1"># at this point there is nothing that could definitely</span>
    <span class="c1"># be a pivot.  To maintain compatibility with existing</span>
    <span class="c1"># behavior, we&#39;ll assume that an illdetermined thing is</span>
    <span class="c1"># non-zero.  We should probably raise a warning in this case</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">possible_zeros</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">newly_determined</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_find_reasonable_pivot_naive</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simpfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper that computes the pivot value and location from a</span>
<span class="sd">    sequence of contiguous matrix column elements. As a side effect</span>
<span class="sd">    of the pivot search, this function may simplify some of the elements</span>
<span class="sd">    of the input column. A list of these simplified entries and their</span>
<span class="sd">    indices are also returned.</span>
<span class="sd">    This function mimics the behavior of _find_reasonable_pivot(),</span>
<span class="sd">    but does less work trying to determine if an indeterminate candidate</span>
<span class="sd">    pivot simplifies to zero. This more naive approach can be much faster,</span>
<span class="sd">    with the trade-off that it may erroneously return a pivot that is zero.</span>

<span class="sd">    `col` is a sequence of contiguous column entries to be searched for</span>
<span class="sd">    a suitable pivot.</span>
<span class="sd">    `iszerofunc` is a callable that returns a Boolean that indicates</span>
<span class="sd">    if its input is zero, or None if no such determination can be made.</span>
<span class="sd">    `simpfunc` is a callable that simplifies its input. It must return</span>
<span class="sd">    its input if it does not simplify its input. Passing in</span>
<span class="sd">    `simpfunc=None` indicates that the pivot search should not attempt</span>
<span class="sd">    to simplify any candidate pivots.</span>

<span class="sd">    Returns a 4-tuple:</span>
<span class="sd">    (pivot_offset, pivot_val, assumed_nonzero, newly_determined)</span>
<span class="sd">    `pivot_offset` is the sequence index of the pivot.</span>
<span class="sd">    `pivot_val` is the value of the pivot.</span>
<span class="sd">    pivot_val and col[pivot_index] are equivalent, but will be different</span>
<span class="sd">    when col[pivot_index] was simplified during the pivot search.</span>
<span class="sd">    `assumed_nonzero` is a boolean indicating if the pivot cannot be</span>
<span class="sd">    guaranteed to be zero. If assumed_nonzero is true, then the pivot</span>
<span class="sd">    may or may not be non-zero. If assumed_nonzero is false, then</span>
<span class="sd">    the pivot is non-zero.</span>
<span class="sd">    `newly_determined` is a list of index-value pairs of pivot candidates</span>
<span class="sd">    that were simplified during the pivot search.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># indeterminates holds the index-value pairs of each pivot candidate</span>
    <span class="c1"># that is neither zero or non-zero, as determined by iszerofunc().</span>
    <span class="c1"># If iszerofunc() indicates that a candidate pivot is guaranteed</span>
    <span class="c1"># non-zero, or that every candidate pivot is zero then the contents</span>
    <span class="c1"># of indeterminates are unused.</span>
    <span class="c1"># Otherwise, the only viable candidate pivots are symbolic.</span>
    <span class="c1"># In this case, indeterminates will have at least one entry,</span>
    <span class="c1"># and all but the first entry are ignored when simpfunc is None.</span>
    <span class="n">indeterminates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="n">col_val_is_zero</span> <span class="o">=</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">col_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col_val_is_zero</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># This pivot candidate is non-zero.</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">col_val_is_zero</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The candidate pivot&#39;s comparison with zero</span>
            <span class="c1"># is indeterminate.</span>
            <span class="n">indeterminates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">col_val</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indeterminates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># All candidate pivots are guaranteed to be zero, i.e. there is</span>
        <span class="c1"># no pivot.</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">simpfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Caller did not pass in a simplification function that might</span>
        <span class="c1"># determine if an indeterminate pivot candidate is guaranteed</span>
        <span class="c1"># to be nonzero, so assume the first indeterminate candidate</span>
        <span class="c1"># is non-zero.</span>
        <span class="k">return</span> <span class="n">indeterminates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indeterminates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[]</span>

    <span class="c1"># newly_determined holds index-value pairs of candidate pivots</span>
    <span class="c1"># that were simplified during the search for a non-zero pivot.</span>
    <span class="n">newly_determined</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_val</span> <span class="ow">in</span> <span class="n">indeterminates</span><span class="p">:</span>
        <span class="n">tmp_col_val</span> <span class="o">=</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">col_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">col_val</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">tmp_col_val</span><span class="p">):</span>
            <span class="c1"># simpfunc() simplified this candidate pivot.</span>
            <span class="n">newly_determined</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">tmp_col_val</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">tmp_col_val</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Candidate pivot simplified to a guaranteed non-zero value.</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">tmp_col_val</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">newly_determined</span>

    <span class="k">return</span> <span class="n">indeterminates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indeterminates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">newly_determined</span>

<span class="k">class</span> <span class="nc">_MinimalMatrix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class providing the minimum functionality</span>
<span class="sd">    for a matrix-like object and implementing every method</span>
<span class="sd">    required for a `MatrixRequired`.  This class does not have everything</span>
<span class="sd">    needed to become a full-fledged sympy object, but it will satisfy the</span>
<span class="sd">    requirements of anything inheriting from `MatrixRequired`.  If you wish</span>
<span class="sd">    to make a specialized matrix type, make sure to implement these</span>
<span class="sd">    methods and properties with the exception of `__init__` and `__repr__`</span>
<span class="sd">    which are included for convenience.&quot;&quot;&quot;</span>

    <span class="n">is_MatrixLike</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_sympify</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sympify</span><span class="p">)</span>
    <span class="n">_class_priority</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">is_Matrix</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_MatrixExpr</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">):</span>
            <span class="c1"># if we passed in a function, use that to populate the indices</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># if we passed in a list of lists, flatten it and set the size</span>
            <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">mat</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot initialize matrix with given parameters&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_normalize_slices</span><span class="p">(</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">col_slice</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Ensure that row_slice and col_slice don&#39;t have</span>
<span class="sd">            `None` in their arguments.  Any integers are converted</span>
<span class="sd">            to slices of length 1&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">row_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">row_slice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">row_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">row_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">col_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">col_slice</span><span class="p">,</span> <span class="n">col_slice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">col_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">col_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">row_slice</span><span class="p">,</span> <span class="n">col_slice</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_coord_to_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the index in _mat corresponding</span>
<span class="sd">            to the (i,j) position in the matrix. &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="c1"># if the coordinates are not slices, make them so</span>
                <span class="c1"># and expand the slices so they don&#39;t contain `None`</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">_normalize_slices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

                <span class="n">rowsList</span><span class="p">,</span> <span class="n">colsList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))[</span><span class="n">i</span><span class="p">],</span> \
                                     <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rowsList</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
                           <span class="n">colsList</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rowsList</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">colsList</span><span class="p">),</span>
                                 <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">))</span>

            <span class="c1"># if the key is a tuple of ints, change</span>
            <span class="c1"># it to an array index</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_coord_to_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;_MinimalMatrix(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MatrixWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper class providing the minimum functionality</span>
<span class="sd">    for a matrix-like object: .rows, .cols, .shape, indexability,</span>
<span class="sd">    and iterability.  CommonMatrix math operations should work</span>
<span class="sd">    on matrix-like objects.  For example, wrapping a numpy</span>
<span class="sd">    matrix in a MatrixWrapper allows it to be passed to CommonMatrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_MatrixLike</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Most attribute access is passed straight through</span>
<span class="sd">        to the stored matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_matrixify</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If `mat` is a Matrix or is matrix-like,</span>
<span class="sd">    return a Matrix or MatrixWrapper object.  Otherwise</span>
<span class="sd">    `mat` is passed through without modification.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;is_Matrix&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_MatrixWrapper</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017 SymPy Development Team.
      Last updated on Jul 27, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>